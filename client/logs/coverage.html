
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gophkeeper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maynagashev/gophkeeper/client/cmd/gophkeeper/main.go (0.0%)</option>
				
				<option value="file1">github.com/maynagashev/gophkeeper/client/internal/api/client.go (84.6%)</option>
				
				<option value="file2">github.com/maynagashev/gophkeeper/client/internal/kdbx/auth.go (98.6%)</option>
				
				<option value="file3">github.com/maynagashev/gophkeeper/client/internal/kdbx/kdbx.go (88.1%)</option>
				
				<option value="file4">github.com/maynagashev/gophkeeper/client/internal/tui/commands.go (86.0%)</option>
				
				<option value="file5">github.com/maynagashev/gophkeeper/client/internal/tui/initialization.go (100.0%)</option>
				
				<option value="file6">github.com/maynagashev/gophkeeper/client/internal/tui/input_helpers.go (87.8%)</option>
				
				<option value="file7">github.com/maynagashev/gophkeeper/client/internal/tui/model.go (100.0%)</option>
				
				<option value="file8">github.com/maynagashev/gophkeeper/client/internal/tui/screen_add.go (88.6%)</option>
				
				<option value="file9">github.com/maynagashev/gophkeeper/client/internal/tui/screen_attachment_delete.go (96.5%)</option>
				
				<option value="file10">github.com/maynagashev/gophkeeper/client/internal/tui/screen_attachment_input.go (82.7%)</option>
				
				<option value="file11">github.com/maynagashev/gophkeeper/client/internal/tui/screen_credentials.go (90.9%)</option>
				
				<option value="file12">github.com/maynagashev/gophkeeper/client/internal/tui/screen_detail.go (76.3%)</option>
				
				<option value="file13">github.com/maynagashev/gophkeeper/client/internal/tui/screen_edit.go (67.6%)</option>
				
				<option value="file14">github.com/maynagashev/gophkeeper/client/internal/tui/screen_list.go (86.8%)</option>
				
				<option value="file15">github.com/maynagashev/gophkeeper/client/internal/tui/screen_login.go (100.0%)</option>
				
				<option value="file16">github.com/maynagashev/gophkeeper/client/internal/tui/screen_login_register_choice.go (100.0%)</option>
				
				<option value="file17">github.com/maynagashev/gophkeeper/client/internal/tui/screen_new_kdbx.go (90.2%)</option>
				
				<option value="file18">github.com/maynagashev/gophkeeper/client/internal/tui/screen_password.go (100.0%)</option>
				
				<option value="file19">github.com/maynagashev/gophkeeper/client/internal/tui/screen_register.go (100.0%)</option>
				
				<option value="file20">github.com/maynagashev/gophkeeper/client/internal/tui/screen_server_url.go (100.0%)</option>
				
				<option value="file21">github.com/maynagashev/gophkeeper/client/internal/tui/screen_sync.go (92.8%)</option>
				
				<option value="file22">github.com/maynagashev/gophkeeper/client/internal/tui/screen_test_helpers.go (92.7%)</option>
				
				<option value="file23">github.com/maynagashev/gophkeeper/client/internal/tui/screen_version.go (96.3%)</option>
				
				<option value="file24">github.com/maynagashev/gophkeeper/client/internal/tui/screen_welcome.go (100.0%)</option>
				
				<option value="file25">github.com/maynagashev/gophkeeper/client/internal/tui/tui.go (18.3%)</option>
				
				<option value="file26">github.com/maynagashev/gophkeeper/client/internal/tui/update.go (64.5%)</option>
				
				<option value="file27">github.com/maynagashev/gophkeeper/client/internal/tui/utils.go (92.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "log"
        "log/slog"
        "os"
        "path/filepath"

        "github.com/maynagashev/gophkeeper/client/internal/tui"
)

const (
        logDir             = "logs"
        logFileName        = "client.log"
        logFilePermissions = 0666
        // Имя переменной окружения для пути к файлу KDBX.
        dbPathEnvVar = "GOPHKEEPER_DB_PATH"
        // Путь к файлу KDBX по умолчанию.
        defaultDBPath = "gophkeeper.kdbx"
)

// Переменные для версии и даты сборки, устанавливаются через ldflags.
var (
        version = "dev" // Значение по умолчанию, если не установлено при сборке
        //nolint:gochecknoglobals // Устанавливается через ldflags при сборке
        buildDate = "unknown" // Значение по умолчанию
        //nolint:gochecknoglobals // Устанавливается через ldflags при сборке
        commitHash = "N/A" // Значение по умолчанию
)

// setupLogging настраивает логирование в файл logs/gophkeeper.log.
func setupLogging() <span class="cov0" title="0">{
        // Создаем директорию logs, если ее нет
        if err := os.MkdirAll(logDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                // Используем panic, так как без логов продолжать нет смысла
                panic("Не удалось создать директорию для логов: " + err.Error())</span>
        }
        <span class="cov0" title="0">logPath := filepath.Join(logDir, logFileName)
        logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, logFilePermissions)
        if err != nil </span><span class="cov0" title="0">{
                panic("Не удалось открыть лог-файл: " + err.Error())</span>
        }
        // Важно: Не закрываем logFile здесь через defer, иначе он закроется
        // сразу после выхода из setupLogging. Файл должен оставаться открытым
        // на время работы приложения. Его закроет ОС при завершении процесса.
        // Либо можно вернуть *os.File и закрывать его в main через defer.
        // Пока оставим так, для простоты.

        // Используем NewTextHandler для читаемости логов
        <span class="cov0" title="0">logHandler := slog.NewTextHandler(logFile, &amp;slog.HandlerOptions{Level: slog.LevelDebug})
        slog.SetDefault(slog.New(logHandler))
        slog.Info("Логгер инициализирован", "path", logPath)</span>
}

func main() <span class="cov0" title="0">{
        // Добавляем флаг для версии
        versionFlag := flag.Bool("version", false, "Показать версию и дату сборки")

        // Настройка логирования
        setupLogging()

        // Определение флагов
        kdbxPathFlag := flag.String("db", defaultDBPath, "Путь к файлу базы данных KDBX (переопределяет "+dbPathEnvVar+")")
        debugModeFlag := flag.Bool("debug", false, "Включить режим отладки TUI")
        serverURLFlag := flag.String("server-url", "", "URL сервера GophKeeper (например, https://localhost:8443)")

        // Парсинг флагов командной строки
        flag.Parse()

        // Если указан флаг --version, выводим информацию и выходим
        if *versionFlag </span><span class="cov0" title="0">{
                // Используем стандартный log для вывода в консоль, так как slog настроен на файл
                log.SetOutput(os.Stdout) // Направляем вывод log в stdout
                log.SetFlags(0)          // Убираем префиксы даты/времени
                log.Println("GophKeeper Client")
                log.Printf("Version: %s", version)
                log.Printf("Build Date: %s", buildDate)
                log.Printf("Commit Hash: %s", commitHash)
                os.Exit(0)
        }</span>

        // Определение финального пути к файлу KDBX
        <span class="cov0" title="0">finalPath := defaultDBPath
        source := "по умолчанию"

        // 1. Проверяем переменную окружения
        if envPath := os.Getenv(dbPathEnvVar); envPath != "" </span><span class="cov0" title="0">{
                finalPath = envPath
                source = "переменная окружения (" + dbPathEnvVar + ")"
        }</span>

        // 2. Проверяем, был ли флаг установлен явно
        <span class="cov0" title="0">dbFlagPresent := false
        flag.Visit(func(f *flag.Flag) </span><span class="cov0" title="0">{
                if f.Name == "db" </span><span class="cov0" title="0">{
                        dbFlagPresent = true
                }</span>
        })

        <span class="cov0" title="0">if dbFlagPresent </span><span class="cov0" title="0">{
                finalPath = *kdbxPathFlag
                source = "флаг -db"
        }</span>

        // Проверка, что итоговый путь не пустой
        <span class="cov0" title="0">if finalPath == "" </span><span class="cov0" title="0">{
                slog.Error(
                        "Путь к файлу базы данных не может быть пустым",
                        "проверьте", "флаг -db и переменную окружения "+dbPathEnvVar,
                )
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">slog.Info("Запуск GophKeeper",
                "db_path", finalPath,
                "source", source,
                "debug_mode", *debugModeFlag,
                "server_url", *serverURLFlag,
        )

        // Запускаем TUI, передавая финальный путь и флаг отладки
        tui.Start(finalPath, *debugModeFlag, *serverURLFlag)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io" // Добавляем для будущих методов
        "net/http"
        "net/url"
        "strconv" // Добавляем для ListVersions
        "time"    // Добавили time

        "github.com/maynagashev/gophkeeper/models" // Импортируем общие модели
)

// ErrAuthorization сигнализирует об ошибке авторизации (401).
var ErrAuthorization = errors.New("ошибка авторизации")

// Client определяет интерфейс для взаимодействия с API сервера GophKeeper.
type Client interface {
        // Register регистрирует нового пользователя.
        Register(ctx context.Context, username, password string) error
        // Login аутентифицирует пользователя и возвращает JWT токен.
        Login(ctx context.Context, username, password string) (string, error)
        // GetVaultMetadata получает метаданные текущей версии хранилища.
        GetVaultMetadata(ctx context.Context) (*models.VaultVersion, error)
        // UploadVault загружает файл хранилища на сервер.
        UploadVault(ctx context.Context, data io.Reader, size int64, contentModifiedAt time.Time) error
        // DownloadVault скачивает текущую версию файла хранилища.
        DownloadVault(ctx context.Context) (io.ReadCloser, *models.VaultVersion, error)
        // ListVersions получает список версий хранилища.
        ListVersions(ctx context.Context, limit, offset int) ([]models.VaultVersion, int64, error)
        // RollbackToVersion откатывает хранилище к указанной версии.
        RollbackToVersion(ctx context.Context, versionID int64) error
        // SetAuthToken устанавливает JWT токен для аутентифицированных запросов.
        SetAuthToken(token string)
}

// httpClient реализует интерфейс Client для взаимодействия с сервером по HTTP.
type httpClient struct {
        baseURL    string       // Базовый URL сервера, например "http://localhost:8080"
        httpClient *http.Client // HTTP клиент для выполнения запросов
        authToken  string       // JWT токен для аутентифицированных запросов
}

// NewHTTPClient создает новый экземпляр API клиента.
func NewHTTPClient(baseURL string) Client <span class="cov8" title="1">{
        return &amp;httpClient{
                baseURL:    baseURL,
                httpClient: &amp;http.Client{}, // Используем стандартный HTTP клиент
        }
}</span>

// Register отправляет запрос на регистрацию на сервер.
func (c *httpClient) Register(ctx context.Context, username, password string) error <span class="cov8" title="1">{
        // Формируем URL эндпоинта регистрации
        registerURL, err := url.JoinPath(c.baseURL, "/api/register")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка формирования URL для регистрации: %w", err)
        }</span>

        // Создаем тело запроса
        <span class="cov8" title="1">requestBody := models.RegisterRequest{
                Username: username,
                Password: password,
        }
        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка кодирования данных для регистрации: %w", err)
        }</span>

        // Создаем HTTP запрос
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, registerURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка создания запроса на регистрацию: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        // Выполняем запрос
        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Добавить обработку сетевых ошибок (таймауты, недоступность сервера)
                return fmt.Errorf("ошибка выполнения запроса на регистрацию: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close() // Важно закрывать тело ответа

        // Проверяем статус код ответа
        if resp.StatusCode != http.StatusCreated </span><span class="cov8" title="1">{
                // TODO: Читать тело ответа для получения сообщения об ошибке от сервера
                return fmt.Errorf("ошибка регистрации на сервере: статус %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span> // Успешная регистрация
}

// Login отправляет запрос на вход на сервер и сохраняет токен.
func (c *httpClient) Login(ctx context.Context, username, password string) (string, error) <span class="cov8" title="1">{
        loginURL, err := url.JoinPath(c.baseURL, "/api/login")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка формирования URL для входа: %w", err)
        }</span>

        <span class="cov8" title="1">requestBody := models.LoginRequest{
                Username: username,
                Password: password,
        }
        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка кодирования данных для входа: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, loginURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка создания запроса на вход: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Добавить обработку сетевых ошибок
                return "", fmt.Errorf("ошибка выполнения запроса на вход: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                // TODO: Читать тело ответа для получения сообщения об ошибке
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                        return "", errors.New("неверное имя пользователя или пароль") // Можно вернуть кастомную ошибку
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("ошибка входа на сервере: статус %d", resp.StatusCode)</span>
        }

        // Декодируем ответ для получения токена
        <span class="cov8" title="1">var loginResponse models.LoginResponse
        if err = json.NewDecoder(resp.Body).Decode(&amp;loginResponse); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ошибка декодирования ответа на вход: %w", err)
        }</span>

        <span class="cov8" title="1">if loginResponse.Token == "" </span><span class="cov0" title="0">{
                return "", errors.New("сервер вернул пустой токен")
        }</span>

        // Сохраняем токен в клиенте для последующих запросов
        <span class="cov8" title="1">c.authToken = loginResponse.Token

        return loginResponse.Token, nil</span>
}

// helper function to add auth header.
func (c *httpClient) setAuthHeader(req *http.Request) error <span class="cov8" title="1">{
        if c.authToken == "" </span><span class="cov8" title="1">{
                return errors.New("токен аутентификации отсутствует") // Или другая ошибка, сигнализирующая о необходимости логина
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+c.authToken)
        return nil</span>
}

// GetVaultMetadata получает метаданные текущей версии хранилища с сервера.
func (c *httpClient) GetVaultMetadata(ctx context.Context) (*models.VaultVersion, error) <span class="cov8" title="1">{
        metadataURL, err := url.JoinPath(c.baseURL, "/api/vault")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка формирования URL для метаданных: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodGet, metadataURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка создания запроса на получение метаданных: %w", err)
        }</span>

        // Добавляем заголовок авторизации
        <span class="cov8" title="1">if err = c.setAuthHeader(req); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Обработка сетевых ошибок
                return nil, fmt.Errorf("ошибка выполнения запроса на получение метаданных: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        return nil, errors.New("хранилище не найдено на сервере") // Кастомная ошибка
                }</span>
                <span class="cov8" title="1">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                        // Возвращаем нашу специальную ошибку
                        return nil, ErrAuthorization
                }</span>
                // TODO: Читать тело для деталей
                <span class="cov8" title="1">return nil, fmt.Errorf("ошибка получения метаданных: статус %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">var metadata models.VaultVersion
        if err = json.NewDecoder(resp.Body).Decode(&amp;metadata); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка декодирования метаданных: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;metadata, nil</span>
}

// UploadVault загружает данные хранилища на сервер.
func (c *httpClient) UploadVault(ctx context.Context, data io.Reader, size int64, contentModifiedAt time.Time) error <span class="cov8" title="1">{
        uploadURL, err := url.JoinPath(c.baseURL, "/api/vault/upload")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка формирования URL для загрузки: %w", err)
        }</span>

        // Используем data напрямую как тело запроса
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, uploadURL, data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка создания запроса на загрузку: %w", err)
        }</span>

        // Устанавливаем необходимые заголовки
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/octet-stream") // Тип контента для KDBX
        req.Header.Set("Content-Length", strconv.FormatInt(size, 10))
        // Добавляем заголовок с временем модификации контента
        modTimeStr := contentModifiedAt.UTC().Format(time.RFC3339)
        req.Header.Set("X-Kdbx-Content-Modified-At", modTimeStr)

        if err = c.setAuthHeader(req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Обработка сетевых ошибок
                return fmt.Errorf("ошибка выполнения запроса на загрузку: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                defer resp.Body.Close() // Закрываем тело в случае ошибки
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                        // Возвращаем нашу специальную ошибку
                        return ErrAuthorization
                }</span>
                <span class="cov8" title="1">if resp.StatusCode == http.StatusConflict </span><span class="cov0" title="0">{
                        return errors.New("конфликт версий при загрузке") // Возвращаем ошибку конфликта
                }</span>
                // TODO: Читать тело для деталей
                <span class="cov8" title="1">return fmt.Errorf("ошибка загрузки на сервер: статус %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span> // Успешная загрузка
}

// DownloadVault скачивает текущую версию файла хранилища с сервера.
func (c *httpClient) DownloadVault(ctx context.Context) (io.ReadCloser, *models.VaultVersion, error) <span class="cov8" title="1">{
        downloadURL, err := url.JoinPath(c.baseURL, "/api/vault/download")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("ошибка формирования URL для скачивания: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodGet, downloadURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("ошибка создания запроса на скачивание: %w", err)
        }</span>
        <span class="cov8" title="1">if err = c.setAuthHeader(req); err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Обработка сетевых ошибок
                return nil, nil, fmt.Errorf("ошибка выполнения запроса на скачивание: %w", err)
        }</span>
        // НЕ закрываем resp.Body здесь, вызывающая сторона должна это сделать

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                defer resp.Body.Close() // Закрываем тело в случае ошибки
                if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        return nil, nil, errors.New("хранилище не найдено для скачивания")
                }</span>
                <span class="cov8" title="1">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                        // Возвращаем нашу специальную ошибку
                        return nil, nil, ErrAuthorization
                }</span>
                // TODO: Читать тело для деталей
                <span class="cov8" title="1">return nil, nil, fmt.Errorf("ошибка скачивания с сервера: статус %d", resp.StatusCode)</span>
        }

        // Пытаемся извлечь метаданные из заголовков (если сервер их туда кладет - пока нет)
        // Здесь мы не можем получить метаданные версии из ответа Download так просто.
        // API сервера возвращает только файл. Клиенту нужно будет отдельно запросить метаданные,
        // если они нужны после скачивания. Либо сервер должен передавать их, например, в заголовках.
        // Пока возвращаем nil для метаданных.
        // Можно было бы распарсить Content-Length, если он есть.
        <span class="cov8" title="1">var meta *models.VaultVersion // Заглушка

        return resp.Body, meta, nil</span> // Возвращаем тело ответа (io.ReadCloser)
}

// ListVersions получает список версий хранилища.
// Возвращает список версий и ID текущей версии.
func (c *httpClient) ListVersions(ctx context.Context, limit, offset int) ([]models.VaultVersion, int64, error) <span class="cov8" title="1">{
        listURL, err := url.JoinPath(c.baseURL, "/api/vault/versions")
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("ошибка формирования URL для списка версий: %w", err)
        }</span>

        // Добавляем параметры пагинации
        <span class="cov8" title="1">query := url.Values{}
        if limit &gt; 0 </span><span class="cov8" title="1">{
                query.Add("limit", strconv.Itoa(limit))
        }</span>
        <span class="cov8" title="1">if offset &gt; 0 </span><span class="cov8" title="1">{
                query.Add("offset", strconv.Itoa(offset))
        }</span>
        <span class="cov8" title="1">if len(query) &gt; 0 </span><span class="cov8" title="1">{
                listURL += "?" + query.Encode()
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodGet, listURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("ошибка создания запроса на список версий: %w", err)
        }</span>
        <span class="cov8" title="1">if err = c.setAuthHeader(req); err != nil </span><span class="cov8" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Обработка сетевых ошибок
                return nil, 0, fmt.Errorf("ошибка выполнения запроса на список версий: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                        // Возвращаем нашу специальную ошибку
                        return nil, 0, ErrAuthorization
                }</span>
                // TODO: Читать тело для деталей
                <span class="cov8" title="1">return nil, 0, fmt.Errorf("ошибка получения списка версий: статус %d", resp.StatusCode)</span>
        }

        // Создаем анонимную структуру для декодирования ответа
        <span class="cov8" title="1">var response struct {
                Versions         []models.VaultVersion `json:"versions"`
                CurrentVersionID int64                 `json:"current_version_id"` // Используем int64, как в модели
        }

        if err = json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("ошибка декодирования списка версий: %w", err)
        }</span>

        <span class="cov8" title="1">return response.Versions, response.CurrentVersionID, nil</span>
}

// RollbackToVersion отправляет запрос на откат к указанной версии.
func (c *httpClient) RollbackToVersion(ctx context.Context, versionID int64) error <span class="cov8" title="1">{
        rollbackURL, err := url.JoinPath(c.baseURL, "/api/vault/rollback")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка формирования URL для отката: %w", err)
        }</span>

        // Создаем тело запроса
        <span class="cov8" title="1">requestBody := map[string]int64{"version_id": versionID} // Простой JSON
        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка кодирования данных для отката: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, rollbackURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка создания запроса на откат: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        if err = c.setAuthHeader(req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Обработка сетевых ошибок
                return fmt.Errorf("ошибка выполнения запроса на откат: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusNoContent </span><span class="cov8" title="1">{ // Ожидаем 204 No Content
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                        // Возвращаем нашу специальную ошибку
                        return ErrAuthorization
                }</span>
                <span class="cov8" title="1">if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        return errors.New("указанная версия или хранилище не найдены для отката")
                }</span>
                <span class="cov8" title="1">if resp.StatusCode == http.StatusBadRequest </span><span class="cov8" title="1">{
                        // TODO: Читать тело ответа
                        return errors.New("неверный запрос на откат (например, некорректный ID версии)")
                }</span>
                // TODO: Читать тело для деталей
                <span class="cov8" title="1">return fmt.Errorf("ошибка отката на сервере: статус %d", resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span> // Успешный откат
}

// SetAuthToken устанавливает токен аутентификации для клиента.
func (c *httpClient) SetAuthToken(token string) <span class="cov8" title="1">{
        c.authToken = token
        // Можно добавить логирование при необходимости
        // slog.Debug("Auth token set in API client")
}</span>

// --- Конец методов API клиента ---
</pre>
		
		<pre class="file" id="file2" style="display: none">package kdbx

import (
        "errors"
        "log/slog"
        "time"

        "github.com/tobischo/gokeepasslib/v3"
        "github.com/tobischo/gokeepasslib/v3/wrappers"
)

const (
        // CustomDataKeyServerURL - ключ для хранения URL сервера в KDBX.
        CustomDataKeyServerURL = "GophKeeperServerURL"
        // CustomDataKeyAuthToken - ключ для хранения JWT токена в KDBX.
        CustomDataKeyAuthToken = "GophKeeperAuthToken" //nolint:gosec // Это имя ключа, а не сам токен
)

// setCustomDataValue обновляет или добавляет значение в слайс CustomData.
// Возвращает обновленный слайс.
func setCustomDataValue(customDataSlice []gokeepasslib.CustomData, key, value string) []gokeepasslib.CustomData <span class="cov8" title="1">{
        found := false
        for i := range customDataSlice </span><span class="cov8" title="1">{
                if customDataSlice[i].Key == key </span><span class="cov8" title="1">{
                        customDataSlice[i].Value = value
                        found = true
                        slog.Debug("Обновлено значение CustomData", "key", key)
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                customDataSlice = append(customDataSlice, gokeepasslib.CustomData{
                        Key:   key,
                        Value: value,
                })
                slog.Debug("Добавлено новое значение CustomData", "key", key)
        }</span>
        <span class="cov8" title="1">return customDataSlice</span>
}

// removeCustomDataValue удаляет значение из слайса CustomData по ключу.
// Возвращает обновленный слайс.
func removeCustomDataValue(customDataSlice []gokeepasslib.CustomData, key string) []gokeepasslib.CustomData <span class="cov8" title="1">{
        newSlice := make([]gokeepasslib.CustomData, 0, len(customDataSlice))
        removed := false
        for _, item := range customDataSlice </span><span class="cov8" title="1">{
                if item.Key != key </span><span class="cov8" title="1">{
                        newSlice = append(newSlice, item)
                }</span> else<span class="cov8" title="1"> {
                        removed = true
                }</span>
        }
        <span class="cov8" title="1">if removed </span><span class="cov8" title="1">{
                slog.Debug("Удалено значение из CustomData", "key", key)
        }</span>
        <span class="cov8" title="1">return newSlice</span>
}

// SaveAuthData сохраняет URL сервера и токен аутентификации
// в пользовательских данных метаданных базы KDBX.
func SaveAuthData(db *gokeepasslib.Database, serverURL, authToken string) error <span class="cov8" title="1">{
        if db == nil || db.Content == nil || db.Content.Meta == nil </span><span class="cov8" title="1">{
                return errors.New("база данных, ее содержимое или метаданные не инициализированы")
        }</span>

        <span class="cov8" title="1">meta := db.Content.Meta
        initialCustomData := make([]gokeepasslib.CustomData, len(meta.CustomData)) // Копируем исходные данные
        copy(initialCustomData, meta.CustomData)
        changed := false // Флаг, что данные действительно изменились

        // Сохраняем/удаляем URL
        if serverURL != "" </span><span class="cov8" title="1">{
                meta.CustomData = setCustomDataValue(meta.CustomData, CustomDataKeyServerURL, serverURL)
        }</span> else<span class="cov8" title="1"> {
                meta.CustomData = removeCustomDataValue(meta.CustomData, CustomDataKeyServerURL)
        }</span>

        // Сохраняем/удаляем токен
        <span class="cov8" title="1">if authToken != "" </span><span class="cov8" title="1">{
                meta.CustomData = setCustomDataValue(meta.CustomData, CustomDataKeyAuthToken, authToken)
        }</span> else<span class="cov8" title="1"> {
                meta.CustomData = removeCustomDataValue(meta.CustomData, CustomDataKeyAuthToken)
        }</span>

        // Проверяем, изменился ли слайс CustomData
        <span class="cov8" title="1">if len(initialCustomData) != len(meta.CustomData) </span><span class="cov8" title="1">{
                changed = true
        }</span> else<span class="cov8" title="1"> {
                // Если длина одинаковая, проверяем содержимое
                for i := range meta.CustomData </span><span class="cov8" title="1">{
                        if initialCustomData[i].Key != meta.CustomData[i].Key || initialCustomData[i].Value != meta.CustomData[i].Value </span><span class="cov8" title="1">{
                                changed = true
                                break</span>
                        }
                }
        }

        // Обновляем время модификации корневой группы, только если CustomData действительно изменились
        <span class="cov8" title="1">if changed </span><span class="cov8" title="1">{
                now := time.Now().UTC()
                // Обновляем время модификации корневой группы
                if db.Content != nil &amp;&amp; db.Content.Root != nil &amp;&amp; len(db.Content.Root.Groups) &gt; 0 </span><span class="cov8" title="1">{
                        // Получаем указатель на корневую группу
                        rootGroup := &amp;db.Content.Root.Groups[0]
                        // Тип Times не указатель, поэтому присваиваем обертку напрямую
                        // Создаем wrappers.TimeWrapper и присваиваем указатель на него
                        modTimeWrapper := wrappers.TimeWrapper{Time: now}      // Создаем экземпляр
                        rootGroup.Times.LastModificationTime = &amp;modTimeWrapper // Присваиваем указатель
                        slog.Debug("Обновлено LastModificationTime корневой группы", "newTime", now)
                }</span> else<span class="cov0" title="0"> {
                        // Логируем, если Content, Root или Groups == nil/пуст
                        slog.Warn("Не удалось обновить LastModificationTime корневой группы:" +
                                " db.Content, Root или Groups == nil/пуст")
                }</span>
        }

        // TODO: Как правильно установить флаг DatabaseChanged? Возможно, не нужно.
        // meta.SetDatabaseChanged(true) // Пока комментируем

        <span class="cov8" title="1">return nil</span>
}

// LoadAuthData извлекает URL сервера и токен аутентификации
// из пользовательских данных метаданных базы KDBX.
func LoadAuthData(db *gokeepasslib.Database) (string, string, error) <span class="cov8" title="1">{
        var serverURL, authToken string
        if db == nil || db.Content == nil || db.Content.Meta == nil </span><span class="cov8" title="1">{
                return "", "", errors.New("база данных, ее содержимое или метаданные не инициализированы для загрузки AuthData")
        }</span>

        <span class="cov8" title="1">meta := db.Content.Meta
        foundURL := false
        foundToken := false

        slog.Debug("Попытка загрузки Auth данных из CustomData", "count", len(meta.CustomData))

        for _, item := range meta.CustomData </span><span class="cov8" title="1">{
                switch item.Key </span>{
                case CustomDataKeyServerURL:<span class="cov8" title="1">
                        serverURL = item.Value
                        foundURL = true
                        slog.Debug("Найден URL сервера в CustomData", "key", item.Key, "value", serverURL)</span>
                case CustomDataKeyAuthToken:<span class="cov8" title="1">
                        authToken = item.Value
                        foundToken = true
                        slog.Debug("Найден токен в CustomData", "key", item.Key)</span>
                }
                <span class="cov8" title="1">if foundURL &amp;&amp; foundToken </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if !foundURL </span><span class="cov8" title="1">{
                slog.Debug("URL сервера не найден в CustomData KDBX")
        }</span>
        <span class="cov8" title="1">if !foundToken </span><span class="cov8" title="1">{
                slog.Debug("Токен аутентификации не найден в CustomData KDBX")
        }</span>

        <span class="cov8" title="1">return serverURL, authToken, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package kdbx

import (
        "errors"
        "fmt"
        "log/slog"
        "os"

        gokeepasslib "github.com/tobischo/gokeepasslib/v3"
)

// TODO: Реализация работы с KDBX файлами

// OpenFile открывает и дешифрует KDBX файл по указанному пути и паролю.
// Возвращает объект базы данных или ошибку.
func OpenFile(filePath string, password string) (*gokeepasslib.Database, error) <span class="cov8" title="1">{
        // Открываем файл
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка открытия файла '%s': %w", filePath, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Создаем новую базу данных для декодирования
        db := gokeepasslib.NewDatabase()
        // Устанавливаем учетные данные для дешифровки
        db.Credentials = gokeepasslib.NewPasswordCredentials(password)

        // Декодируем (дешифруем) файл
        err = gokeepasslib.NewDecoder(file).Decode(db)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка дешифрования файла '%s': %w", filePath, err)
        }</span>

        // Разблокируем защищенные значения (пароли и т.д.)
        <span class="cov8" title="1">err = db.UnlockProtectedEntries()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка разблокировки защищенных полей: %w", err)
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// GetAllEntries рекурсивно обходит все группы и возвращает плоский список всех записей.
func GetAllEntries(db *gokeepasslib.Database) []gokeepasslib.Entry <span class="cov8" title="1">{
        var entries []gokeepasslib.Entry
        if db == nil || db.Content == nil || db.Content.Root == nil </span><span class="cov8" title="1">{
                return entries
        }</span>
        <span class="cov8" title="1">collectEntries(&amp;entries, db.Content.Root.Groups)
        return entries</span>
}

// collectEntries - вспомогательная рекурсивная функция для сбора записей.
func collectEntries(entries *[]gokeepasslib.Entry, groups []gokeepasslib.Group) <span class="cov8" title="1">{
        for _, group := range groups </span><span class="cov8" title="1">{
                *entries = append(*entries, group.Entries...)
                collectEntries(entries, group.Groups)
        }</span>
}

// TODO: Добавить функции для сохранения, добавления, редактирования, удаления записей.

// CreateDatabase создает новую базу данных KDBX с указанным паролем.
// Пока это только заглушка для тестов, которая всегда возвращает ошибку.
func CreateDatabase(_ string, _ string) (*gokeepasslib.Database, error) <span class="cov8" title="1">{
        return nil, errors.New("функция CreateDatabase еще не реализована")
}</span>

// SaveFile кодирует и сохраняет базу данных KDBX в указанный файл.
func SaveFile(db *gokeepasslib.Database, filePath string, password string) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                return errors.New("база данных не инициализирована (nil)")
        }</span>

        // Устанавливаем учетные данные, если их нет (нужны для сохранения)
        <span class="cov8" title="1">if db.Credentials == nil </span><span class="cov8" title="1">{
                if password == "" </span><span class="cov8" title="1">{
                        return errors.New("пароль не может быть пустым при сохранении")
                }</span>
                <span class="cov0" title="0">db.Credentials = gokeepasslib.NewPasswordCredentials(password)</span>
        }

        // Важно: перед сохранением нужно заблокировать защищенные поля!
        <span class="cov8" title="1">err := db.LockProtectedEntries()
        if err != nil </span><span class="cov0" title="0">{
                // Логируем ошибку, но не прерываем сохранение, если не критично
                slog.Warn("Не удалось заблокировать поля перед сохранением", "error", err)
        }</span>

        // Открываем файл для записи (перезаписываем существующий)
        <span class="cov8" title="1">file, err := os.Create(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ошибка создания/открытия файла '%s' для записи: %w", filePath, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Кодируем и записываем БД в файл
        keepassEncoder := gokeepasslib.NewEncoder(file)
        if encodeErr := keepassEncoder.Encode(db); encodeErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка кодирования и записи БД в файл '%s': %w", filePath, encodeErr)
        }</span>

        // Разблокируем обратно после сохранения (если нужно продолжить работу)
        // TODO: Решить, нужно ли это делать здесь или после вызова SaveFile
        <span class="cov8" title="1">err = db.UnlockProtectedEntries()
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("Не удалось разблокировать поля после сохранения", "error", err)
                // Не возвращаем ошибку, так как сохранение прошло успешно
        }</span>

        <span class="cov8" title="1">return nil</span> // Сохранение успешно
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package tui

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "os"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/tobischo/gokeepasslib/v3"

        "github.com/maynagashev/gophkeeper/client/internal/kdbx"
        "github.com/maynagashev/gophkeeper/models"
)

// openKdbxCmd асинхронно открывает файл базы.
func openKdbxCmd(path, password string) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                db, err := kdbx.OpenFile(path, password)
                if err != nil </span><span class="cov8" title="1">{
                        return errMsg{err: err}
                }</span>
                <span class="cov0" title="0">return dbOpenedMsg{db: db}</span>
        }
}

// saveKdbxCmd асинхронно сохраняет файл базы.
func saveKdbxCmd(db *gokeepasslib.Database, path, password string) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := kdbx.SaveFile(db, path, password)
                if err != nil </span><span class="cov0" title="0">{
                        return dbSaveErrorMsg{err: err}
                }</span>
                <span class="cov0" title="0">return dbSavedMsg{}</span>
        }
}

// clearStatusCmd возвращает команду, которая отправит clearStatusMsg через delay.
func clearStatusCmd(delay time.Duration) tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(delay, func(_ time.Time) tea.Msg </span><span class="cov8" title="1">{
                return clearStatusMsg{}
        }</span>)
}

// --- Сообщения и команды для API --- //

type loginSuccessMsg struct {
        Token string
}

type LoginError struct {
        err error
}

func (e LoginError) Error() string <span class="cov8" title="1">{
        return e.err.Error()
}</span>

// makeLoginCmd выполняет вход через API.
func (m *model) makeLoginCmd(username, password string) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                ctx := context.Background()
                token, err := m.apiClient.Login(ctx, username, password)
                if err != nil </span><span class="cov8" title="1">{
                        // Возвращаем исходную ошибку API клиента без добавления контекста
                        return LoginError{err: err}
                }</span>
                <span class="cov8" title="1">return loginSuccessMsg{Token: token}</span>
        }
}

// Сообщения для регистрации.
type registerSuccessMsg struct { // Успешная регистрация не возвращает токен
}

type RegisterError struct {
        err error
}

func (e RegisterError) Error() string <span class="cov8" title="1">{
        return e.err.Error()
}</span>

// makeRegisterCmd выполняет регистрацию через API.
func (m *model) makeRegisterCmd(username, password string) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                ctx := context.Background()
                err := m.apiClient.Register(ctx, username, password)
                if err != nil </span><span class="cov8" title="1">{
                        // Возвращаем исходную ошибку API клиента без добавления контекста
                        return RegisterError{err: err}
                }</span>
                <span class="cov8" title="1">return registerSuccessMsg{}</span>
        }
}

// --- Сообщения и команды для Синхронизации --- //

// SyncError сообщает об ошибке во время процесса синхронизации.
type SyncError struct {
        err error
}

func (e SyncError) Error() string <span class="cov8" title="1">{
        return e.err.Error()
}</span>

// syncStartedMsg сигнализирует об успешном начале процесса синхронизации (предусловия пройдены).
type syncStartedMsg struct{}

// serverMetadataMsg содержит метаданные, полученные с сервера.
type serverMetadataMsg struct {
        metadata *models.VaultVersion // nil если не найдено (404)
        found    bool
}

// localMetadataMsg содержит метаданные локального файла.
type localMetadataMsg struct {
        modTime time.Time // Время модификации
        found   bool      // Файл существует?
}

// syncUploadSuccessMsg сигнализирует об успешной загрузке хранилища на сервер.
type syncUploadSuccessMsg struct{}

// syncDownloadSuccessMsg сигнализирует об успешном скачивании хранилища с сервера.
// Включает флаг необходимости перезагрузки базы данных.
type syncDownloadSuccessMsg struct {
        reloadNeeded bool // Обычно true, чтобы обновить TUI
}

const defaultFilePerm = 0600

// startSyncCmd проверяет предусловия и запускает процесс синхронизации.
func startSyncCmd(m *model) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                slog.Info("Запуск проверки предусловий для синхронизации...")

                // 1. Проверка URL
                if m.serverURL == "" </span><span class="cov8" title="1">{
                        err := errors.New("URL сервера не настроен")
                        slog.Warn("Предусловие синхронизации не выполнено: URL", "error", err)
                        return SyncError{err: err}
                }</span>
                // 2. Проверка токена
                <span class="cov8" title="1">if m.authToken == "" </span><span class="cov8" title="1">{
                        err := errors.New("необходимо войти на сервер")
                        slog.Warn("Предусловие синхронизации не выполнено: Token", "error", err)
                        return SyncError{err: err}
                }</span>
                // 3. Проверка API клиента
                <span class="cov8" title="1">if m.apiClient == nil </span><span class="cov8" title="1">{
                        err := errors.New("API клиент не инициализирован")
                        slog.Error("Критическая ошибка: apiClient nil", "error", err)
                        return SyncError{err: err}
                }</span>
                // 4. Проверка базы данных
                <span class="cov8" title="1">if m.db == nil </span><span class="cov8" title="1">{
                        err := errors.New("локальная база данных не загружена")
                        slog.Error("Критическая ошибка: m.db nil", "error", err)
                        return SyncError{err: err}
                }</span>

                <span class="cov8" title="1">slog.Info("Предусловия синхронизации выполнены.")
                // TODO: Здесь будет запуск получения метаданных с сервера
                // Возвращаем сообщение для обновления статуса (например, "Синхронизация...")
                // Заменяем nil на syncStartedMsg
                return syncStartedMsg{}</span> // Заменить на команду получения метаданных ПОСЛЕ установки статуса
        }
}

// fetchServerMetadataCmd получает метаданные хранилища с сервера.
func fetchServerMetadataCmd(m *model) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                slog.Debug("Получение метаданных с сервера", "url", m.serverURL)
                ctx := context.Background() // Используем background context
                meta, err := m.apiClient.GetVaultMetadata(ctx)

                if err != nil </span><span class="cov8" title="1">{
                        // Проверяем специфичные ошибки API клиента с помощью switch
                        switch err.Error() </span>{
                        case "хранилище не найдено на сервере":<span class="cov0" title="0"> // Проверка на текст ошибки
                                slog.Info("Хранилище не найдено на сервере.")
                                return serverMetadataMsg{metadata: nil, found: false}</span>
                        case "ошибка авторизации (невалидный или просроченный токен?)":<span class="cov0" title="0">
                                slog.Warn("Ошибка авторизации при получении метаданных с сервера", "error", err)
                                return SyncError{err: errors.New("ошибка авторизации")}</span>
                        default:<span class="cov8" title="1">
                                // Другая ошибка (сетевая, 5xx, ошибка декодирования)
                                slog.Error("Ошибка получения метаданных с сервера", "error", err)
                                return SyncError{err: fmt.Errorf("ошибка сети или сервера: %w", err)}</span>
                        }
                }

                // Успешно получили метаданные
                <span class="cov8" title="1">slog.Debug("Метаданные с сервера получены", "versionId", meta.ID, "createdAt", meta.CreatedAt)
                return serverMetadataMsg{metadata: meta, found: true}</span>
        }
}

// fetchLocalMetadataCmd получает время модификации локального файла.
func fetchLocalMetadataCmd(m *model) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                slog.Debug("Получение метаданных локального файла", "path", m.kdbxPath)
                // Используем os.Stat для получения времени модификации файла
                // TODO: Заменить на получение времени модификации из m.db (e.g., m.db.Meta.DataLastModified?), когда найдем способ.
                fileInfo, err := os.Stat(m.kdbxPath)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                                slog.Info("Локальный файл KDBX не найден.")
                                return localMetadataMsg{found: false} // Файл не найден
                        }</span>
                        // Другая ошибка при доступе к файлу
                        <span class="cov0" title="0">slog.Error("Ошибка получения метаданных локального файла", "path", m.kdbxPath, "error", err)
                        return SyncError{err: fmt.Errorf("ошибка доступа к локальному файлу: %w", err)}</span>
                }
                // Успешно получили информацию о файле
                <span class="cov8" title="1">modTime := fileInfo.ModTime()
                slog.Debug("Метаданные локального файла получены (os.Stat)", "modTime", modTime)
                return localMetadataMsg{modTime: modTime, found: true}</span>
        }
}

// uploadVaultCmd загружает локальный файл KDBX на сервер.
func uploadVaultCmd(m *model) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                // Шаг 1: Убедиться, что все изменения из TUI применены к m.db (как в Ctrl+S)
                slog.Info("Подготовка к загрузке: обновление m.db из TUI...")
                applyUIChangesToDB(m)
                slog.Info("Обновление m.db завершено.")

                // === Получаем время модификации файла (из os.Stat) ===
                // TODO: Заменить на получение времени модификации из m.db, когда найдем способ.
                fileInfo, err := os.Stat(m.kdbxPath)
                if err != nil </span><span class="cov8" title="1">{
                        // Ошибка получения статы файла - критично для получения времени модификации
                        slog.Error("Ошибка получения метаданных локального файла перед загрузкой", "path", m.kdbxPath, "error", err)
                        return SyncError{err: fmt.Errorf("ошибка доступа к локальному файлу перед загрузкой: %w", err)}
                }</span>
                <span class="cov8" title="1">contentModTime := fileInfo.ModTime() // Используем время модификации файла
                // =====================================================

                // Шаг 2: Заблокировать и сохранить m.db во временный буфер для загрузки
                if m.db == nil </span><span class="cov8" title="1">{
                        slog.Error("Попытка загрузки хранилища, но m.db is nil")
                        return SyncError{err: errors.New("локальная база не загружена")}
                }</span>
                <span class="cov8" title="1">if err = m.db.LockProtectedEntries(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Не удалось заблокировать поля перед сохранением в буфер", "error", err)
                }</span>
                <span class="cov8" title="1">buf := new(bytes.Buffer)
                encoder := gokeepasslib.NewEncoder(buf)
                if err = encoder.Encode(m.db); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Ошибка кодирования KDBX в буфер перед загрузкой", "error", err)
                        // Разблокируем обратно в случае ошибки кодирования
                        if unlockErr := m.db.UnlockProtectedEntries(); unlockErr != nil </span><span class="cov0" title="0">{
                                slog.Warn("Не удалось разблокировать поля после ошибки кодирования", "error", unlockErr)
                        }</span>
                        <span class="cov0" title="0">return SyncError{err: fmt.Errorf("ошибка подготовки данных для загрузки: %w", err)}</span>
                }
                // Разблокируем поля после успешного кодирования для дальнейшей работы
                <span class="cov8" title="1">if err = m.db.UnlockProtectedEntries(); err != nil </span><span class="cov0" title="0">{
                        slog.Warn("Не удалось разблокировать поля после кодирования в буфер", "error", err)
                        // Продолжаем, так как данные уже в буфере
                }</span>

                <span class="cov8" title="1">dataSize := int64(buf.Len())

                // Шаг 3: Вызвать API для загрузки, передавая время модификации файла
                slog.Info("Запуск загрузки KDBX на сервер...", "fileModTime", contentModTime)
                ctx := context.Background()
                err = m.apiClient.UploadVault(ctx, buf, dataSize, contentModTime) // Передаем fileModTime
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("Ошибка загрузки KDBX на сервер", "error", err)
                        return SyncError{err: fmt.Errorf("ошибка загрузки на сервер: %w", err)}
                }</span>

                <span class="cov8" title="1">slog.Info("Загрузка KDBX на сервер успешно завершена.")
                return syncUploadSuccessMsg{}</span>
        }
}

// downloadVaultCmd скачивает файл KDBX с сервера и перезаписывает локальный.
func downloadVaultCmd(m *model) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                slog.Info("Запуск скачивания KDBX с сервера...")
                ctx := context.Background()
                reader, _, err := m.apiClient.DownloadVault(ctx) // Метаданные пока не используем
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("Ошибка скачивания KDBX с сервера", "error", err)
                        return SyncError{err: fmt.Errorf("ошибка скачивания с сервера: %w", err)}
                }</span>
                <span class="cov8" title="1">defer reader.Close()

                // Шаг 2: Создать/открыть локальный файл для записи (перезапись)
                slog.Debug("Открытие локального файла для записи", "path", m.kdbxPath)
                file, err := os.OpenFile(m.kdbxPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, defaultFilePerm)
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("Ошибка открытия локального файла для записи", "path", m.kdbxPath, "error", err)
                        return SyncError{err: fmt.Errorf("ошибка записи локального файла: %w", err)}
                }</span>
                <span class="cov8" title="1">defer file.Close()

                // Шаг 3: Скопировать данные из ответа в файл
                _, err = io.Copy(file, reader)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("Ошибка копирования данных в локальный файл", "error", err)
                        return SyncError{err: fmt.Errorf("ошибка сохранения скачанного файла: %w", err)}
                }</span>

                <span class="cov8" title="1">slog.Info("Скачивание KDBX с сервера и сохранение локально завершено.")
                // Отправляем сообщение об успехе и необходимости перезагрузки
                return syncDownloadSuccessMsg{reloadNeeded: true}</span>
        }
}

// applyUIChangesToDB применяет изменения из компонентов TUI (например, списка) к m.db.
// Эта функция должна быть похожа на логику в handleGlobalKeys для Ctrl+S.
func applyUIChangesToDB(m *model) <span class="cov8" title="1">{
        // TODO: Избежать дублирования кода с handleGlobalKeys
        items := m.entryList.Items()
        updatedCount := 0
        for _, item := range items </span><span class="cov8" title="1">{
                if listItem, ok := item.(entryItem); ok </span><span class="cov8" title="1">{
                        dbEntryPtr := findEntryInDB(m.db, listItem.entry.UUID)
                        if dbEntryPtr != nil </span><span class="cov8" title="1">{
                                entryToSave := deepCopyEntry(listItem.entry)
                                *dbEntryPtr = entryToSave
                                updatedCount++
                        }</span> else<span class="cov8" title="1"> {
                                slog.Warn("Запись из списка не найдена в m.db при подготовке к загрузке", "uuid", listItem.entry.UUID)
                        }</span>
                }
        }
        <span class="cov8" title="1">slog.Debug("Применено изменений из UI в m.db перед загрузкой", "updated_count", updatedCount)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package tui

import (
        "fmt"
        "time"

        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/textinput"
        "github.com/charmbracelet/lipgloss"
        "github.com/maynagashev/gophkeeper/client/internal/api"
        "github.com/maynagashev/gophkeeper/models"
)

// Константы, используемые при инициализации.
const (
        initPasswordCharLimit = 156
        initPasswordWidth     = 20
        initPathCharLimit     = 4096
        initURLCharLimit      = 1024
        initURLWidth          = 50
        initUserCharLimit     = 128
        initUserWidth         = 30
)

// Константы для работы с данными.
const (
        bytesPerKilobyte = 1024.0 // Добавлено для mnd
)

// versionItem представляет элемент в списке версий.
type versionItem struct {
        version   models.VaultVersion
        isCurrent bool // Флаг текущей активной версии
}

func (i versionItem) Title() string <span class="cov8" title="1">{
        // Формат: ID (+ "Текущая" если активная версия)
        title := fmt.Sprintf("Версия #%d", i.version.ID)
        if i.isCurrent </span><span class="cov8" title="1">{
                title += " (Текущая)"
        }</span>
        <span class="cov8" title="1">return title</span>
}

func (i versionItem) Description() string <span class="cov8" title="1">{
        description := ""

        // Добавляем время создания, если есть
        if i.version.ContentModifiedAt != nil </span><span class="cov8" title="1">{
                timeStr := i.version.ContentModifiedAt.Format(time.RFC3339)
                description += fmt.Sprintf("Изменена: %s", timeStr)
        }</span>

        // Добавляем размер, если есть
        <span class="cov8" title="1">if i.version.SizeBytes != nil </span><span class="cov8" title="1">{
                if description != "" </span><span class="cov8" title="1">{
                        description += " | "
                }</span>
                <span class="cov8" title="1">sizeKB := float64(*i.version.SizeBytes) / bytesPerKilobyte // Используем константу
                description += fmt.Sprintf("Размер: %.2f KB", sizeKB)</span>
        }

        // Если ничего нет, просто выводим ID
        <span class="cov8" title="1">if description == "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("ID: %d", i.version.ID)
        }</span>

        <span class="cov8" title="1">return description</span>
}

func (i versionItem) FilterValue() string <span class="cov8" title="1">{
        // Фильтрация не используется для этого списка, но интерфейс требует реализации
        return i.Title()
}</span>

// initPasswordInput инициализирует основное поле ввода пароля.
func initPasswordInput() textinput.Model <span class="cov8" title="1">{
        ti := textinput.New()
        ti.Placeholder = "Мастер-пароль"
        ti.Focus()
        ti.CharLimit = initPasswordCharLimit
        ti.Width = initPasswordWidth
        ti.EchoMode = textinput.EchoPassword
        return ti
}</span>

// initEntryList инициализирует основной компонент списка для записей.
func initEntryList() list.Model <span class="cov8" title="1">{
        delegate := list.NewDefaultDelegate()
        // Настраиваем цвета для лучшей видимости
        delegate.Styles.NormalTitle = delegate.Styles.NormalTitle.
                Foreground(lipgloss.Color("252")).
                Background(lipgloss.Color("235"))
        delegate.Styles.NormalDesc = delegate.Styles.NormalDesc.
                Foreground(lipgloss.Color("245")).
                Background(lipgloss.Color("235"))
        delegate.Styles.SelectedTitle = delegate.Styles.SelectedTitle.
                Foreground(lipgloss.Color("212")).
                Background(lipgloss.Color("237")).
                BorderLeftForeground(lipgloss.Color("212"))
        delegate.Styles.SelectedDesc = delegate.Styles.SelectedDesc.
                Foreground(lipgloss.Color("240")).
                Background(lipgloss.Color("237")).
                BorderLeftForeground(lipgloss.Color("212"))

        l := list.New([]list.Item{}, delegate, 0, 0)
        l.Title = "Записи"
        l.SetShowHelp(false) // Мы переопределяем справку
        l.SetShowStatusBar(true)
        l.SetFilteringEnabled(true)
        l.Styles.Title = list.DefaultStyles().Title.Bold(true)
        l.Styles.PaginationStyle = list.DefaultStyles().PaginationStyle
        l.Styles.HelpStyle = list.DefaultStyles().HelpStyle
        return l
}</span>

// initAttachmentDeleteList инициализирует список для удаления вложений.
func initAttachmentDeleteList() list.Model <span class="cov8" title="1">{
        l := list.New([]list.Item{}, list.NewDefaultDelegate(), 0, 0)
        l.Title = "Выберите вложение для удаления"
        l.SetShowHelp(false)
        l.SetShowStatusBar(false)
        l.SetFilteringEnabled(false)
        l.Styles.Title = list.DefaultStyles().Title.Bold(true)
        return l
}</span>

// initAttachmentPathInput инициализирует поле ввода пути к вложению.
func initAttachmentPathInput() textinput.Model <span class="cov8" title="1">{
        ti := textinput.New()
        ti.Placeholder = "/path/to/your/file"
        ti.CharLimit = initPathCharLimit
        ti.Width = defaultListWidth - passwordInputOffset // Предполагается, что константы доступны
        return ti
}</span>

// initNewKdbxPasswordInputs инициализирует поля для создания нового пароля KDBX.
func initNewKdbxPasswordInputs() (textinput.Model, textinput.Model) <span class="cov8" title="1">{
        newPass1 := textinput.New()
        newPass1.Placeholder = "Новый мастер-пароль"
        newPass1.Focus()
        newPass1.CharLimit = initPasswordCharLimit
        newPass1.Width = initPasswordWidth
        newPass1.EchoMode = textinput.EchoPassword

        newPass2 := textinput.New()
        newPass2.Placeholder = "Подтвердите пароль"
        newPass2.CharLimit = initPasswordCharLimit
        newPass2.Width = initPasswordWidth
        newPass2.EchoMode = textinput.EchoPassword
        return newPass1, newPass2
}</span>

// initSyncMenu инициализирует компонент списка для меню синхронизации/сервера.
func initSyncMenu() list.Model <span class="cov8" title="1">{
        syncMenuDelegate := list.NewDefaultDelegate()
        // Устанавливаем ненулевые размеры по умолчанию для диагностики
        defaultSyncMenuWidth := 40
        defaultSyncMenuHeight := 20
        syncMenuList := list.New([]list.Item{
                syncMenuItem{title: "Настроить URL сервера", id: "configure_url"},
                syncMenuItem{title: "Войти / Зарегистрироваться", id: "login_register"},
                syncMenuItem{title: "Синхронизировать сейчас", id: "sync_now"},
                syncMenuItem{title: "Просмотреть версии", id: "view_versions"},
                syncMenuItem{title: "Выйти на сервере", id: "logout"},
        }, syncMenuDelegate, defaultSyncMenuWidth, defaultSyncMenuHeight)
        syncMenuList.Title = ""
        syncMenuList.SetShowHelp(false)
        syncMenuList.SetShowStatusBar(false)
        syncMenuList.SetFilteringEnabled(false)
        syncMenuList.Styles.Title = list.DefaultStyles().Title.Bold(true)
        return syncMenuList
}</span>

// initServerURLInput инициализирует поле ввода URL сервера.
func initServerURLInput() textinput.Model <span class="cov8" title="1">{
        ti := textinput.New()
        ti.Placeholder = defaultServerURL // Предполагается, что константы доступны
        ti.CharLimit = initURLCharLimit
        ti.Width = initURLWidth
        return ti
}</span>

// initLoginInputs инициализирует поля для экрана входа.
func initLoginInputs() (textinput.Model, textinput.Model) <span class="cov8" title="1">{
        loginUserInput := textinput.New()
        loginUserInput.Placeholder = "Имя пользователя"
        loginUserInput.CharLimit = initUserCharLimit
        loginUserInput.Width = initUserWidth

        loginPassInput := textinput.New()
        loginPassInput.Placeholder = "Пароль"
        loginPassInput.CharLimit = initPasswordCharLimit
        loginPassInput.Width = initUserWidth
        loginPassInput.EchoMode = textinput.EchoPassword
        return loginUserInput, loginPassInput
}</span>

// initRegisterInputs инициализирует поля для экрана регистрации.
func initRegisterInputs() (textinput.Model, textinput.Model) <span class="cov8" title="1">{
        regUserInput := textinput.New()
        regUserInput.Placeholder = "Имя пользователя"
        regUserInput.CharLimit = initUserCharLimit
        regUserInput.Width = initUserWidth

        regPassInput := textinput.New()
        regPassInput.Placeholder = "Пароль"
        regPassInput.CharLimit = initPasswordCharLimit
        regPassInput.Width = initUserWidth
        regPassInput.EchoMode = textinput.EchoPassword
        return regUserInput, regPassInput
}</span>

// initDocStyle инициализирует основной стиль документа.
func initDocStyle() lipgloss.Style <span class="cov8" title="1">{
        // Предполагается, что константы доступны
        return lipgloss.NewStyle().Margin(docStyleMarginVertical, docStyleMarginHorizontal)
}</span>

// initVersionList инициализирует список для отображения версий хранилища.
func initVersionList() list.Model <span class="cov8" title="1">{
        versionDelegate := list.NewDefaultDelegate()

        // Настройка стилей для выделения текущей версии
        versionDelegate.Styles.SelectedTitle = versionDelegate.Styles.SelectedTitle.
                Foreground(lipgloss.Color("212")).
                Background(lipgloss.Color("237")).
                BorderLeftForeground(lipgloss.Color("212"))

        versionDelegate.Styles.SelectedDesc = versionDelegate.Styles.SelectedDesc.
                Foreground(lipgloss.Color("240")).
                Background(lipgloss.Color("237")).
                BorderLeftForeground(lipgloss.Color("212"))

        versionList := list.New([]list.Item{}, versionDelegate, defaultListWidth, defaultListHeight)
        versionList.Title = "История версий"
        versionList.SetShowHelp(false)
        versionList.SetShowStatusBar(true)
        versionList.SetFilteringEnabled(false)
        versionList.Styles.Title = list.DefaultStyles().Title.Bold(true)

        return versionList
}</span>

// initModel создает начальное состояние модели.
func initModel(kdbxPath string, debugMode bool, serverURL string, apiClient api.Client) model <span class="cov8" title="1">{
        passwordInput := initPasswordInput()
        entryList := initEntryList()
        attachmentDelList := initAttachmentDeleteList()
        pathInput := initAttachmentPathInput()
        newPass1, newPass2 := initNewKdbxPasswordInputs()
        syncMenuList := initSyncMenu()
        serverURLInput := initServerURLInput()
        loginUserInput, loginPassInput := initLoginInputs()
        regUserInput, regPassInput := initRegisterInputs()
        docStyle := initDocStyle()
        versionList := initVersionList()

        return model{
                state:                     welcomeScreen,
                passwordInput:             passwordInput,
                kdbxPath:                  kdbxPath,
                entryList:                 entryList,
                attachmentList:            attachmentDelList,
                attachmentPathInput:       pathInput,
                newPasswordInput1:         newPass1,
                newPasswordInput2:         newPass2,
                newPasswordFocusedField:   0,
                loginStatus:               "Не выполнен",
                lastSyncStatus:            "Не синхронизировалось",
                syncServerMenu:            syncMenuList,
                serverURLInput:            serverURLInput,
                loginUsernameInput:        loginUserInput,
                loginPasswordInput:        loginPassInput,
                registerUsernameInput:     regUserInput,
                registerPasswordInput:     regPassInput,
                loginRegisterFocusedField: 0,
                docStyle:                  docStyle,
                debugMode:                 debugMode,
                versionList:               versionList,
                serverURL:                 serverURL,
                apiClient:                 apiClient,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package tui

import (
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

const (
        // Количество полей, обрабатываемых handleCredentialsInput (имя/пароль).
        numCredentialFields = 2
)

// handleCredentialsKeys обрабатывает нажатия Tab, Shift+Tab и Enter в полях ввода.
// Возвращает модель, команду и флаг, указывающий, была ли клавиша обработана.
func (m *model) handleCredentialsKeys(
        keyMsg tea.KeyMsg,
        input1 *textinput.Model,
        input2 *textinput.Model,
        focusedFieldIdx *int,
        onEnterCmd func() (tea.Model, tea.Cmd),
) (tea.Model, tea.Cmd, bool) <span class="cov8" title="1">{
        switch keyMsg.String() </span>{
        case keyTab:<span class="cov8" title="1">
                *focusedFieldIdx = (*focusedFieldIdx + 1) % numCredentialFields
                if *focusedFieldIdx == 0 </span><span class="cov0" title="0">{
                        input2.Blur()
                        input1.Focus()
                }</span> else<span class="cov8" title="1"> {
                        input1.Blur()
                        input2.Focus()
                }</span>
                <span class="cov8" title="1">return m, textinput.Blink, true</span> // Клавиша обработана
        case keyShiftTab:<span class="cov8" title="1">
                *focusedFieldIdx = (*focusedFieldIdx + numCredentialFields - 1) % numCredentialFields
                if *focusedFieldIdx == 0 </span><span class="cov8" title="1">{
                        input2.Blur()
                        input1.Focus()
                }</span> else<span class="cov0" title="0"> {
                        input1.Blur()
                        input2.Focus()
                }</span>
                <span class="cov8" title="1">return m, textinput.Blink, true</span> // Клавиша обработана
        case keyEnter:<span class="cov8" title="1">
                if *focusedFieldIdx == 0 </span><span class="cov8" title="1">{ // Активно первое поле
                        *focusedFieldIdx = 1
                        input1.Blur()
                        input2.Focus()
                        return m, textinput.Blink, true // Клавиша обработана (переход фокуса)
                }</span>
                // Активно второе поле - вызываем действие
                <span class="cov8" title="1">model, cmd := onEnterCmd()
                return model, cmd, true</span> // Клавиша обработана (вызов действия)
        default:<span class="cov8" title="1">
                return m, nil, false</span> // Клавиша не обработана этим хендлером
        }
}

// handleCredentialsInput обрабатывает ввод в двух полях (например, имя/пароль),
// переключение фокуса между ними и действия по Enter/Esc.
func (m *model) handleCredentialsInput(
        msg tea.Msg,
        input1 *textinput.Model,
        input2 *textinput.Model,
        focusedFieldIdx *int,
        onEnterCmd func() (tea.Model, tea.Cmd),
        previousState screenState,
) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd
        var cmd tea.Cmd

        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                // Сначала обрабатываем Esc
                if keyMsg.String() == keyEsc </span><span class="cov8" title="1">{
                        m.state = previousState
                        input1.Blur()
                        input2.Blur()
                        return m, tea.ClearScreen
                }</span>

                // Затем обрабатываем Tab, Shift+Tab, Enter
                <span class="cov8" title="1">newModel, keyCmd, handled := m.handleCredentialsKeys(keyMsg, input1, input2, focusedFieldIdx, onEnterCmd)
                if handled </span><span class="cov8" title="1">{
                        return newModel, keyCmd
                }</span>
        }

        // Если это не Esc или другая обработанная клавиша, обновляем активное поле ввода
        <span class="cov8" title="1">currentIdx := *focusedFieldIdx
        activeInput := input1
        if currentIdx == 1 </span><span class="cov0" title="0">{
                activeInput = input2
        }</span>
        <span class="cov8" title="1">*activeInput, cmd = activeInput.Update(msg)
        cmds = append(cmds, cmd)

        return m, tea.Batch(cmds...)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package tui

import (
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/textinput"
        "github.com/charmbracelet/lipgloss"
        "github.com/gofrs/flock"
        "github.com/maynagashev/gophkeeper/client/internal/api"
        "github.com/maynagashev/gophkeeper/models"
        "github.com/tobischo/gokeepasslib/v3"
)

// Состояния (экраны) приложения.
type screenState int

const (
        welcomeScreen              screenState = iota // Приветственный экран
        passwordInputScreen                           // Экран ввода пароля
        entryListScreen                               // Экран списка записей
        entryDetailScreen                             // Экран деталей записи
        entryEditScreen                               // Экран редактирования записи
        entryAddScreen                                // Экран добавления новой записи
        attachmentListDeleteScreen                    // Экран выбора вложения для удаления
        attachmentPathInputScreen                     // Экран ввода пути к добавляемому вложению
        newKdbxPasswordScreen                         // Экран ввода пароля для нового KDBX файла
        // Экраны для синхронизации и сервера.
        syncServerScreen          // Экран "Синхронизация и Сервер"
        serverURLInputScreen      // Экран ввода URL сервера
        loginRegisterChoiceScreen // Экран выбора "Войти или Зарегистрироваться?"
        loginScreen               // Экран ввода данных для входа
        registerScreen            // Экран ввода данных для регистрации
        versionListScreen         // Экран списка версий
)

// String возвращает строковое представление screenState.
func (s screenState) String() string <span class="cov8" title="1">{
        switch s </span>{
        case welcomeScreen:<span class="cov8" title="1">
                return "welcomeScreen"</span>
        case passwordInputScreen:<span class="cov8" title="1">
                return "passwordInputScreen"</span>
        case newKdbxPasswordScreen:<span class="cov8" title="1">
                return "newKdbxPasswordScreen"</span>
        case entryListScreen:<span class="cov8" title="1">
                return "entryListScreen"</span>
        case entryDetailScreen:<span class="cov8" title="1">
                return "entryDetailScreen"</span>
        case entryEditScreen:<span class="cov8" title="1">
                return "entryEditScreen"</span>
        case entryAddScreen:<span class="cov8" title="1">
                return "entryAddScreen"</span>
        case attachmentListDeleteScreen:<span class="cov8" title="1">
                return "attachmentListDeleteScreen"</span>
        case attachmentPathInputScreen:<span class="cov8" title="1">
                return "attachmentPathInputScreen"</span>
        case syncServerScreen:<span class="cov8" title="1">
                return "syncServerScreen"</span>
        case serverURLInputScreen:<span class="cov8" title="1">
                return "serverURLInputScreen"</span>
        case loginRegisterChoiceScreen:<span class="cov8" title="1">
                return "loginRegisterChoiceScreen"</span>
        case loginScreen:<span class="cov8" title="1">
                return "loginScreen"</span>
        case registerScreen:<span class="cov8" title="1">
                return "registerScreen"</span>
        case versionListScreen:<span class="cov8" title="1">
                return "versionListScreen"</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("unknownScreen(%d)", s)</span>
        }
}

// Поля, доступные для редактирования.
const (
        // Стандартные поля.
        editableFieldTitle = iota
        editableFieldUserName
        editableFieldPassword
        editableFieldURL
        editableFieldNotes
        // Поля карты.
        editableFieldCardNumber
        editableFieldCardHolderName
        editableFieldExpiryDate
        editableFieldCVV
        editableFieldPIN
        // Конец списка.
        numEditableFields // Общее количество редактируемых полей
)

// Имена полей (используются как плейсхолдеры и ключи в KDBX).
const (
        fieldNameTitle          = "Title"
        fieldNameUserName       = "UserName"
        fieldNamePassword       = "Password"
        fieldNameURL            = "URL"
        fieldNameNotes          = "Notes"
        fieldNameCardNumber     = "CardNumber"
        fieldNameCardHolderName = "CardHolderName"
        fieldNameExpiryDate     = "ExpiryDate"
        fieldNameCVV            = "CVV"
        fieldNamePIN            = "PIN"
)

// Константы для TUI.
const (
        defaultListWidth    = 80 // Стандартная ширина терминала для списка
        defaultListHeight   = 24 // Стандартная высота терминала для списка
        passwordInputOffset = 4  // Отступ для поля ввода пароля

        keyEnter    = "enter" // Клавиша Enter
        keyQuit     = "q"     // Клавиша выхода
        keyBack     = "b"     // Клавиша возврата
        keyEsc      = "esc"   // Клавиша Escape
        keyEdit     = "e"     // Клавиша редактирования
        keyAdd      = "a"     // Клавиша добавления
        keyTab      = "tab"
        keyShiftTab = "shift+tab"
        keyUp       = "up"
        keyDown     = "down"
        keyCtrlC    = "ctrl+c" // Добавляем константу
)

const numNewPasswordFields = 2 // Количество полей на экране создания пароля

// entryItem представляет элемент списка записей.
// Реализует интерфейс list.Item.
type entryItem struct {
        entry gokeepasslib.Entry
}

func (i entryItem) Title() string <span class="cov8" title="1">{
        // Пытаемся получить значение поля "Title"
        title := i.entry.GetTitle()
        if title == "" </span><span class="cov8" title="1">{
                // Если Title пустой, используем Username
                title = i.entry.GetContent("UserName")
        }</span>
        <span class="cov8" title="1">if title == "" </span><span class="cov8" title="1">{
                // Если и Username пустой, используем UUID
                title = hex.EncodeToString(i.entry.UUID[:])
        }</span>
        <span class="cov8" title="1">return title</span>
}

func (i entryItem) Description() string <span class="cov8" title="1">{
        // В описании можно показать Username или URL
        username := i.entry.GetContent("UserName")
        url := i.entry.GetContent("URL")
        var desc string // Объявляем переменную без инициализации
        switch </span>{
        case username != "" &amp;&amp; url != "":<span class="cov8" title="1">
                desc = fmt.Sprintf("User: %s | URL: %s", username, url)</span>
        case username != "":<span class="cov8" title="1">
                desc = fmt.Sprintf("User: %s", username)</span>
        case url != "":<span class="cov8" title="1">
                desc = fmt.Sprintf("URL: %s", url)</span>
        default:<span class="cov8" title="1">
                desc = ""</span>
        }

        // Добавляем индикатор наличия вложений
        <span class="cov8" title="1">if len(i.entry.Binaries) &gt; 0 </span><span class="cov8" title="1">{
                if desc != "" </span><span class="cov8" title="1">{
                        desc += " " // Добавляем пробел, если описание уже есть
                }</span>
                <span class="cov8" title="1">desc += fmt.Sprintf("[A:%d]", len(i.entry.Binaries))</span> // Показываем количество вложений
        }

        <span class="cov8" title="1">return desc</span>
}

func (i entryItem) FilterValue() string <span class="cov8" title="1">{ return i.Title() }</span>

// Структура для сообщения об успешном открытии файла.
type dbOpenedMsg struct {
        db *gokeepasslib.Database
}

// Структура для сообщения об ошибке.
type errMsg struct {
        err error
}

// Структуры для сообщений о сохранении.
type dbSavedMsg struct{}

type dbSaveErrorMsg struct {
        err error
}

// model представляет состояние TUI приложения.
type model struct {
        state               screenState
        kdbxPath            string // Путь к файлу KDBX
        password            string // Сохраненный мастер-пароль
        db                  *gokeepasslib.Database
        fileLock            *flock.Flock        // Объект блокировки файла
        lockAcquired        bool                // Флаг: удалось ли получить блокировку
        readOnlyMode        bool                // Флаг: приложение в режиме только для чтения
        passwordInput       textinput.Model     // Поле ввода пароля для существующего файла
        entryList           list.Model          // Список записей
        selectedEntry       *entryItem          // Выбранная запись для просмотра/редактирования
        detailScroll        int                 //nolint:unused // Задел на будущее для скроллинга деталей
        editInputs          []textinput.Model   // Поля ввода для редактирования
        focusedField        int                 // Индекс активного поля при редактировании/добавлении
        editingEntry        *gokeepasslib.Entry // Копия записи при редактировании/добавлении
        attachmentList      list.Model          // Список вложений для выбора/удаления
        attachmentPathInput textinput.Model     // Поле ввода пути для добавления вложения
        attachmentError     error               // Ошибка при добавлении вложения
        previousScreenState screenState         // Предыдущее состояние (для возврата)
        savingStatus        string              // Статус сохранения (отображается внизу)
        statusTimer         *time.Timer         // Таймер для очистки статуса сохранения
        width               int
        height              int
        listMutex           sync.Mutex //nolint:unused // Задел на будущее для синхронизации

        // Поля для создания нового KDBX
        newPasswordInput1       textinput.Model // Первое поле ввода нового пароля
        newPasswordInput2       textinput.Model // Второе поле для подтверждения пароля
        newPasswordFocusedField int             // 0 или 1, указывает на активное поле
        confirmPasswordError    string          // Сообщение об ошибке несовпадения паролей

        // Поле для временного хранения вложений при добавлении
        newEntryAttachments []struct {
                Name    string
                Content []byte
        }
        // Поля для подтверждения удаления вложения
        confirmationPrompt string          // Текст запроса подтверждения
        itemToDelete       *attachmentItem // Вложение, выбранное для удаления
        err                error           // Последняя ошибка для отображения

        // -- Поля для интеграции с сервером --
        apiClient                 api.Client      // Клиент для взаимодействия с API
        serverURL                 string          // URL сервера
        authToken                 string          // JWT токен аутентификации
        loginStatus               string          // Статус входа ("Не выполнен", "Выполнен как...")
        lastSyncStatus            string          // Статус последней синхронизации
        syncServerMenu            list.Model      // Меню действий на экране синхронизации
        serverURLInput            textinput.Model // Поле для ввода URL сервера
        loginUsernameInput        textinput.Model // Поле для ввода имени пользователя при входе
        loginPasswordInput        textinput.Model // Поле для ввода пароля при входе
        registerUsernameInput     textinput.Model // Поле для ввода имени пользователя при регистрации
        registerPasswordInput     textinput.Model // Поле для ввода пароля при регистрации
        loginRegisterFocusedField int             // Индекс активного поля на экранах входа/регистрации/URL
        docStyle                  lipgloss.Style  // Общий стиль для обрамления View
        debugMode                 bool            // Флаг режима отладки

        // -- Поля для состояния синхронизации --
        isSyncing          bool                 // Флаг: идет ли процесс синхронизации
        serverMeta         *models.VaultVersion // Метаданные сервера
        serverMetaFound    bool                 // Найдены ли метаданные на сервере
        localMetaModTime   time.Time            // Время модификации локального файла
        localMetaFound     bool                 // Найден ли локальный файл
        receivedServerMeta bool                 // Флаг: получены ли метаданные сервера
        receivedLocalMeta  bool                 // Флаг: получены ли метаданные локального файла

        // -- Поля для работы с версиями --
        versionList                list.Model            // Список версий
        versions                   []models.VaultVersion // Полученные с сервера версии
        loadingVersions            bool                  // Флаг: идет ли загрузка списка версий
        selectedVersionForRollback *models.VaultVersion  // Выбранная версия для отката
        confirmRollback            bool                  // Флаг: требуется подтверждение отката
        rollbackError              error                 // Ошибка при откате

        // -- Добавляем карту для текстов помощи --
        helpTextMap map[screenState]string
}

// Сообщение для очистки статуса.
type clearStatusMsg struct{}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tui

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/tobischo/gokeepasslib/v3"
        w "github.com/tobischo/gokeepasslib/v3/wrappers"
)

// prepareAddScreen инициализирует поля для экрана добавления.
func (m *model) prepareAddScreen() <span class="cov8" title="1">{
        m.editInputs = make([]textinput.Model, numEditableFields)
        // Создаем пустую запись для заполнения
        newEntry := gokeepasslib.NewEntry()
        m.editingEntry = &amp;newEntry
        m.focusedField = editableFieldTitle // Начинаем с поля Title
        // Сбрасываем вложения, которые могли остаться от предыдущего добавления
        m.newEntryAttachments = nil

        // Используем константы имен полей как плейсхолдеры
        placeholders := map[int]string{
                editableFieldTitle:          fieldNameTitle,
                editableFieldUserName:       fieldNameUserName,
                editableFieldPassword:       fieldNamePassword,
                editableFieldURL:            fieldNameURL,
                editableFieldNotes:          fieldNameNotes,
                editableFieldCardNumber:     fieldNameCardNumber,
                editableFieldCardHolderName: fieldNameCardHolderName,
                editableFieldExpiryDate:     fieldNameExpiryDate,
                editableFieldCVV:            fieldNameCVV,
                editableFieldPIN:            fieldNamePIN,
        }

        for i := range numEditableFields </span><span class="cov8" title="1">{
                m.editInputs[i] = textinput.New()
                m.editInputs[i].Placeholder = placeholders[i]

                // Настраиваем маскирование для чувствительных полей
                switch i </span>{
                case editableFieldPassword, editableFieldCVV, editableFieldPIN:<span class="cov8" title="1">
                        m.editInputs[i].EchoMode = textinput.EchoPassword</span>
                case editableFieldCardNumber:<span class="cov8" title="1"></span>
                        // Пока оставляем обычным
                }

                // Первое поле делаем активным
                <span class="cov8" title="1">if i == m.focusedField </span><span class="cov8" title="1">{
                        m.editInputs[i].Focus()
                }</span>
        }
}

// createEntryFromInputs создает новую запись gokeepasslib.Entry на основе
// данных из полей ввода (inputs) и временных вложений (attachments).
// Также добавляет бинарные данные в базу (db).
func createEntryFromInputs(db *gokeepasslib.Database, inputs []textinput.Model, attachments []struct {
        Name    string
        Content []byte
}) gokeepasslib.Entry <span class="cov8" title="1">{
        newEntry := gokeepasslib.NewEntry()
        now := time.Now()
        creationTime := w.TimeWrapper{Time: now}
        modificationTime := w.TimeWrapper{Time: now}
        accessTime := w.TimeWrapper{Time: now}
        newEntry.Times.CreationTime = &amp;creationTime
        newEntry.Times.LastModificationTime = &amp;modificationTime
        newEntry.Times.LastAccessTime = &amp;accessTime

        // Добавляем обычные поля
        for _, input := range inputs </span><span class="cov8" title="1">{
                fieldName := input.Placeholder
                newValue := input.Value()
                if newValue != "" </span><span class="cov8" title="1">{
                        valueData := gokeepasslib.ValueData{
                                Key:   fieldName,
                                Value: gokeepasslib.V{Content: newValue},
                        }
                        if fieldName == fieldNamePassword </span><span class="cov8" title="1">{
                                valueData.Value.Protected = w.NewBoolWrapper(true)
                        }</span>
                        <span class="cov8" title="1">newEntry.Values = append(newEntry.Values, valueData)</span>
                }
        }

        // Добавляем вложения
        <span class="cov8" title="1">if db != nil &amp;&amp; len(attachments) &gt; 0 </span><span class="cov8" title="1">{
                for _, att := range attachments </span><span class="cov8" title="1">{
                        binary := db.AddBinary(att.Content)
                        if binary == nil </span><span class="cov0" title="0">{
                                slog.Error("Не удалось добавить бинарные данные в базу", "name", att.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">binaryRef := binary.CreateReference(att.Name)
                        newEntry.Binaries = append(newEntry.Binaries, binaryRef)
                        slog.Info("Добавлено вложение к новой записи", "name", att.Name, "binary_id", binary.ID)</span>
                }
        }

        <span class="cov8" title="1">return newEntry</span>
}

// updateEntryAddScreen обрабатывает сообщения для экрана добавления записи.
//
//nolint:nestif // Сложность из-за обработки разных клавиш и навигации
func (m *model) updateEntryAddScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Если в режиме ReadOnly, сразу возвращаемся к списку
        if m.readOnlyMode </span><span class="cov0" title="0">{
                slog.Warn("Попытка доступа к экрану добавления в режиме Read-Only.")
                m.state = entryListScreen
                return m, tea.ClearScreen
        }</span>

        <span class="cov8" title="1">var cmds []tea.Cmd

        // Обрабатываем только KeyMsg
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyEsc, keyBack:<span class="cov8" title="1">
                        // Отмена добавления
                        m.state = entryListScreen
                        m.editInputs = nil // Очищаем поля ввода
                        m.newEntryAttachments = nil
                        slog.Info("Отмена добавления, возврат к списку")
                        return m, tea.ClearScreen</span>

                case keyTab, keyDown:<span class="cov8" title="1">
                        // Переход к следующему полю
                        m.focusedField = (m.focusedField + 1) % numEditableFields
                        cmds = m.updateFocus()
                        return m, tea.Batch(cmds...)</span>

                case keyShiftTab, keyUp:<span class="cov8" title="1">
                        // Переход к предыдущему полю
                        m.focusedField = (m.focusedField - 1 + numEditableFields) % numEditableFields
                        cmds = m.updateFocus()
                        return m, tea.Batch(cmds...)</span>

                case keyEnter:<span class="cov8" title="1">
                        // Создаем запись из введенных данных и вложений
                        newEntry := createEntryFromInputs(m.db, m.editInputs, m.newEntryAttachments)
                        m.newEntryAttachments = nil // Очищаем временное хранилище

                        // Добавляем newEntry в m.db (в первую группу)
                        if m.db != nil &amp;&amp; m.db.Content != nil &amp;&amp; m.db.Content.Root != nil </span><span class="cov0" title="0">{
                                if len(m.db.Content.Root.Groups) &gt; 0 </span><span class="cov0" title="0">{
                                        m.db.Content.Root.Groups[0].Entries = append(m.db.Content.Root.Groups[0].Entries, newEntry)
                                }</span> else<span class="cov0" title="0"> {
                                        // Если нет групп, создаем первую
                                        newGroup := gokeepasslib.NewGroup()
                                        newGroup.Name = "General"
                                        newGroup.Entries = append(newGroup.Entries, newEntry)
                                        m.db.Content.Root.Groups = append(m.db.Content.Root.Groups, newGroup)
                                        slog.Warn("Группы не найдены, создана новая группа 'General'")
                                }</span>
                        } else<span class="cov8" title="1"> {
                                slog.Error("Не удалось добавить запись в m.db: база данных или Root не инициализированы")
                        }</span>

                        // Добавляем newEntry в m.entryList
                        <span class="cov8" title="1">newItem := entryItem{entry: newEntry}
                        insertCmd := m.entryList.InsertItem(len(m.entryList.Items()), newItem)
                        m.entryList.Title = fmt.Sprintf("Записи в '%s' (%d)", m.kdbxPath, len(m.entryList.Items()))
                        slog.Info("Новая запись добавлена", "title", newEntry.GetTitle())

                        // Возвращаемся к списку
                        m.state = entryListScreen
                        m.editInputs = nil
                        return m, tea.Batch(tea.ClearScreen, insertCmd)</span>

                case "ctrl+o":<span class="cov8" title="1"> // Добавить вложение
                        slog.Info("Переход к экрану ввода пути для добавления вложения")
                        m.previousScreenState = m.state // Запоминаем текущий экран (entryAddScreen)
                        m.state = attachmentPathInputScreen
                        m.attachmentPathInput.Reset()
                        m.attachmentPathInput.Focus()
                        m.attachmentError = nil // Сбрасываем предыдущую ошибку
                        // Добавляем очистку экрана
                        return m, tea.Batch(textinput.Blink, tea.ClearScreen)</span>
                }
        } // конец if keyMsg, ok := msg.(tea.KeyMsg)

        // Если сообщение не KeyMsg или было обработано выше (кроме навигации/Enter/Esc),
        // обновляем активное поле ввода.
        <span class="cov8" title="1">var cmd tea.Cmd
        m.editInputs[m.focusedField], cmd = m.editInputs[m.focusedField].Update(msg)
        cmds = append(cmds, cmd)

        return m, tea.Batch(cmds...)</span>
}

// updateFocus обновляет фокус полей ввода для экрана добавления И редактирования.
// Переименована из updateFocusAdd.
func (m *model) updateFocus() []tea.Cmd <span class="cov8" title="1">{
        cmds := make([]tea.Cmd, len(m.editInputs))
        for i := range len(m.editInputs) </span><span class="cov8" title="1">{
                if i == m.focusedField </span><span class="cov8" title="1">{
                        cmds[i] = m.editInputs[i].Focus()
                }</span> else<span class="cov8" title="1"> {
                        m.editInputs[i].Blur()
                }</span>
        }
        <span class="cov8" title="1">return cmds</span>
}

// viewEntryAddScreen отрисовывает экран добавления новой записи.
func (m *model) viewEntryAddScreen() string <span class="cov8" title="1">{
        s := "Добавление новой записи\n\n"
        s += "Введите данные для новой записи:\n"
        // Отображаем все поля ввода (включая поля карты)
        for i, input := range m.editInputs </span><span class="cov8" title="1">{
                focusIndicator := "  "
                if m.focusedField == i </span><span class="cov8" title="1">{
                        focusIndicator = "&gt; "
                }</span>
                <span class="cov8" title="1">s += fmt.Sprintf("%s%s: %s\n", focusIndicator, input.Placeholder, input.View())</span>
        }

        // Отображаем добавляемые вложения
        <span class="cov8" title="1">s += "\n--- Вложения для добавления ---\n"
        if len(m.newEntryAttachments) == 0 </span><span class="cov8" title="1">{
                s += "(Нет вложений)\n"
        }</span> else<span class="cov8" title="1"> {
                for i, att := range m.newEntryAttachments </span><span class="cov8" title="1">{
                        s += fmt.Sprintf(" [%d] %s (%d байт)\n", i, att.Name, len(att.Content))
                }</span>
        }

        // s += "(Enter - добавить, Ctrl+C - выход)\n" // Убрали, т.к. добавляется в View
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tui

import (
        "fmt"
        "log/slog"

        tea "github.com/charmbracelet/bubbletea"
)

// updateAttachmentListDeleteScreen обрабатывает сообщения для экрана удаления вложений.
func (m *model) updateAttachmentListDeleteScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Если в режиме ReadOnly, сразу возвращаемся к редактированию
        if m.readOnlyMode </span><span class="cov8" title="1">{
                slog.Warn("Попытка доступа к экрану удаления вложения в режиме Read-Only.")
                m.state = entryEditScreen
                return m, tea.ClearScreen
        }</span>

        <span class="cov8" title="1">var cmds []tea.Cmd

        // Если есть активный запрос на подтверждение, обрабатываем его
        if m.confirmationPrompt != "" </span><span class="cov8" title="1">{
                if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                        switch keyMsg.String() </span>{
                        case keyEnter, "y", "d":<span class="cov8" title="1"> // Подтверждение
                                return m.performAttachmentDelete()</span>
                        case keyEsc, keyBack, "n":<span class="cov8" title="1"> // Отмена
                                m.confirmationPrompt = ""
                                m.itemToDelete = nil
                                return m, nil</span> // Остаемся на экране, убираем промпт
                        }
                }
                // Игнорируем другие сообщения, пока активен промпт
                <span class="cov0" title="0">return m, nil</span>
        }

        // Обновляем список вложений (если нет активного промпта)
        <span class="cov8" title="1">var listCmd tea.Cmd
        m.attachmentList, listCmd = m.attachmentList.Update(msg)
        cmds = append(cmds, listCmd)

        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyEsc, keyBack:<span class="cov8" title="1">
                        // Отмена удаления, возврат к редактированию
                        m.state = entryEditScreen
                        slog.Info("Отмена удаления вложения, возврат к редактированию")
                        return m, tea.ClearScreen</span>

                case keyEnter, "d":<span class="cov8" title="1">
                        selectedItem := m.attachmentList.SelectedItem()
                        if selectedItem != nil </span><span class="cov8" title="1">{
                                if item, itemOk := selectedItem.(attachmentItem); itemOk </span><span class="cov8" title="1">{
                                        // Запрашиваем подтверждение
                                        m.itemToDelete = &amp;item
                                        m.confirmationPrompt = fmt.Sprintf("Удалить вложение '%s'? (y/n)", item.name)
                                        return m, nil // Остаемся на экране, показываем промпт
                                }</span>
                                // Если не itemOk, выводим ошибку и остаемся
                                <span class="cov0" title="0">slog.Error("Не удалось преобразовать выбранный элемент к attachmentItem")</span>
                        }
                        // Если selectedItem == nil, тоже остаемся
                        <span class="cov8" title="1">return m, nil</span>
                }
        }

        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// performAttachmentDelete выполняет фактическое удаление вложения после подтверждения.
func (m *model) performAttachmentDelete() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if m.itemToDelete == nil </span><span class="cov8" title="1">{
                slog.Error("Попытка удаления без выбранного itemToDelete")
                m.confirmationPrompt = ""
                return m, nil
        }</span>

        <span class="cov8" title="1">itemName := m.itemToDelete.name
        itemID := m.itemToDelete.id
        slog.Info("Подтверждено удаление ссылки на вложение", "name", itemName, "id", itemID)

        // Находим и удаляем BinaryReference из среза m.editingEntry.Binaries
        foundIndex := -1
        for i, binRef := range m.editingEntry.Binaries </span><span class="cov8" title="1">{
                if binRef.Value.ID == itemID </span><span class="cov8" title="1">{
                        foundIndex = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if foundIndex != -1 </span><span class="cov8" title="1">{
                m.editingEntry.Binaries = append(m.editingEntry.Binaries[:foundIndex], m.editingEntry.Binaries[foundIndex+1:]...)
                slog.Info("Ссылка на вложение успешно удалена из редактируемой записи")
                m.savingStatus = fmt.Sprintf("Вложение '%s' удалено.", itemName) // Устанавливаем статус
        }</span> else<span class="cov8" title="1"> {
                slog.Warn("Не удалось найти BinaryReference для удаления в editingEntry")
                m.savingStatus = fmt.Sprintf("Не удалось удалить вложение '%s'.", itemName) // Устанавливаем статус ошибки
        }</span>

        // Сбрасываем состояние подтверждения и возвращаемся к экрану редактирования
        <span class="cov8" title="1">m.confirmationPrompt = ""
        m.itemToDelete = nil
        m.state = entryEditScreen
        // Возвращаем ClearScreen, чтобы статус был виден на чистом экране редактирования
        return m, tea.ClearScreen</span>
}

// viewAttachmentListDeleteScreen отрисовывает экран удаления вложений.
func (m *model) viewAttachmentListDeleteScreen() string <span class="cov8" title="1">{
        var s string
        if m.confirmationPrompt != "" </span><span class="cov8" title="1">{
                // Отображаем только промпт подтверждения
                s = m.confirmationPrompt
        }</span> else<span class="cov8" title="1"> {
                // Отображаем список вложений
                // TODO: Устанавливать размер списка корректно
                s = m.attachmentList.View()
        }</span>
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tui

import (
        "errors"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// updateAttachmentPathInputScreen обрабатывает ввод пути к файлу вложения.
func (m *model) updateAttachmentPathInputScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd
        var cmd tea.Cmd

        // Обновляем поле ввода пути
        m.attachmentPathInput, cmd = m.attachmentPathInput.Update(msg)
        cmds = append(cmds, cmd)

        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyEsc:<span class="cov8" title="1">
                        // Отмена ввода, возврат на предыдущий экран
                        slog.Info("Отмена ввода пути вложения")
                        m.state = m.previousScreenState
                        m.attachmentPathInput.Blur()
                        m.attachmentError = nil // Очищаем ошибку при отмене
                        // Нужно вернуть фокус на предыдущий компонент?
                        // Зависит от previousScreenState. Пока просто ClearScreen.
                        return m, tea.ClearScreen</span>

                case keyEnter:<span class="cov8" title="1">
                        return m.handleAttachmentPathConfirm()</span>
                }
        }

        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// handleAttachmentPathConfirm обрабатывает подтверждение ввода пути и чтение файла.
func (m *model) handleAttachmentPathConfirm() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        filePath := m.attachmentPathInput.Value()
        slog.Info("Попытка добавить вложение из файла", "path", filePath)

        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                m.attachmentError = fmt.Errorf("ошибка чтения файла: %w", err)
                slog.Error("Ошибка чтения файла для вложения", "path", filePath, "error", err)
                return m, nil // Остаемся на экране ввода
        }</span>

        <span class="cov8" title="1">fileName := filepath.Base(filePath)
        slog.Info("Файл успешно прочитан", "name", fileName, "size", len(content))

        // Добавляем вложение
        //nolint:exhaustive // Игнорируем exhaustive, т.к. другие состояния не должны сюда приводить
        switch m.previousScreenState </span>{
        case entryEditScreen:<span class="cov8" title="1">
                if m.editingEntry != nil &amp;&amp; m.db != nil </span><span class="cov8" title="1">{
                        binary := m.db.AddBinary(content)
                        if binary == nil </span><span class="cov0" title="0">{
                                m.attachmentError = fmt.Errorf("не удалось добавить бинарные данные '%s' в базу", fileName)
                                slog.Error("Ошибка при добавлении бинарных данных в базу (edit screen)", "name", fileName)
                                return m, nil // Остаемся на экране ввода
                        }</span>
                        <span class="cov8" title="1">binaryRef := binary.CreateReference(fileName)
                        m.editingEntry.Binaries = append(m.editingEntry.Binaries, binaryRef)
                        slog.Info("Вложение добавлено к редактируемой записи", "name", fileName, "binary_id", binary.ID)</span>
                } else<span class="cov0" title="0"> {
                        slog.Error("Не удалось добавить вложение: editingEntry или db is nil")
                        m.attachmentError = errors.New("внутренняя ошибка: нет контекста для добавления вложения")
                        return m, nil // Остаемся на экране ввода
                }</span>
        case entryAddScreen:<span class="cov0" title="0">
                m.newEntryAttachments = append(m.newEntryAttachments, struct {
                        Name    string
                        Content []byte
                }{fileName, content})
                slog.Info("Вложение добавлено во временный список для новой записи", "name", fileName)</span>
        default:<span class="cov8" title="1">
                // Этого не должно происходить
                slog.Error("Неожиданный предыдущий экран при добавлении вложения", "state", m.previousScreenState)
                m.attachmentError = fmt.Errorf("внутренняя ошибка: неизвестный контекст %v", m.previousScreenState)
                return m, nil</span> // Остаемся на экране ввода
        }

        // Возвращаемся на предыдущий экран
        <span class="cov8" title="1">m.state = m.previousScreenState
        m.attachmentPathInput.Blur()
        m.attachmentError = nil                                            // Очищаем ошибку после успеха
        m.savingStatus = fmt.Sprintf("Вложение '%s' добавлено.", fileName) // Устанавливаем статус
        return m, tea.ClearScreen</span>
}

// viewAttachmentPathInputScreen отрисовывает экран ввода пути к файлу вложения.
func (m *model) viewAttachmentPathInputScreen() string <span class="cov8" title="1">{
        var b strings.Builder
        b.WriteString("Введите полный путь к файлу для добавления вложения:\n")
        b.WriteString(m.attachmentPathInput.View())
        b.WriteString("\n\n")

        if m.attachmentError != nil </span><span class="cov0" title="0">{
                b.WriteString(fmt.Sprintf("Ошибка: %s\n", m.attachmentError))
        }</span>

        <span class="cov8" title="1">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tui

import (
        "strings"

        "github.com/charmbracelet/bubbles/textinput"
        "github.com/charmbracelet/lipgloss"
)

// viewCredentialsScreen отображает общий экран ввода данных (логин/пароль).
func (m *model) viewCredentialsScreen(title, hint string, usernameInput, passwordInput textinput.Model) string <span class="cov8" title="1">{
        var b strings.Builder

        // Определяем стили здесь, чтобы избежать дублирования в каждом вызывающем месте
        titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#FAFAFA"))
        subtleStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))    // Серый
        errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#F25D94")) // Красный для ошибок

        b.WriteString(titleStyle.Render(title) + "\n\n")
        b.WriteString(usernameInput.View() + "\n")
        b.WriteString(passwordInput.View() + "\n\n")
        b.WriteString(subtleStyle.Render(hint) + "\n")
        if m.err != nil </span><span class="cov0" title="0">{
                b.WriteString(errorStyle.Render("Ошибка: "+m.err.Error()) + "\n")
        }</span>
        <span class="cov8" title="1">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tui

import (
        "fmt"
        "log/slog"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/tobischo/gokeepasslib/v3"
)

const (
        minCardLengthForMask = 9 // Минимальная длина номера карты для маскирования (4 + 4 + 1 символ между ними)
        visibleCardDigits    = 4 // Количество видимых цифр с каждой стороны
)

// updateEntryDetailScreen обрабатывает сообщения для экрана деталей записи.
func (m *model) updateEntryDetailScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyEsc, keyBack:<span class="cov8" title="1">
                        m.state = entryListScreen
                        m.selectedEntry = nil // Сбрасываем выбранную запись
                        slog.Info("Возврат к списку записей")
                        return m, tea.ClearScreen</span>
                case keyEdit:<span class="cov8" title="1">
                        // Переход к редактированию (только если не Read-Only)
                        if !m.readOnlyMode &amp;&amp; m.selectedEntry != nil </span><span class="cov8" title="1">{
                                m.prepareEditScreen()
                                m.state = entryEditScreen
                                slog.Info("Переход к редактированию записи", "title", m.selectedEntry.Title())
                                return m, tea.ClearScreen
                        }</span>
                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

// renderStandardFields форматирует стандартные поля записи для отображения.
// Он также удаляет отображенные поля из переданной карты valuesMap.
func renderStandardFields(_ gokeepasslib.Entry, valuesMap map[string]gokeepasslib.ValueData) string <span class="cov8" title="1">{
        s := ""
        // Включаем поля карты в стандартный порядок
        desiredOrder := []string{
                "Title", "UserName", "Password", "URL", "Notes",
                fieldNameCardNumber, fieldNameCardHolderName, fieldNameExpiryDate, fieldNameCVV, fieldNamePIN,
        }
        // Не создаем новую карту, используем переданную

        for _, key := range desiredOrder </span><span class="cov8" title="1">{
                if val, ok := valuesMap[key]; ok </span><span class="cov8" title="1">{
                        valueContent := val.Value.Content
                        // Маскируем чувствительные поля
                        switch val.Key </span>{
                        case fieldNamePassword, fieldNameCVV, fieldNamePIN:<span class="cov8" title="1">
                                valueContent = "********"</span>
                        case fieldNameCardNumber:<span class="cov8" title="1">
                                valueContent = maskCardNumber(valueContent)</span>
                        }
                        <span class="cov8" title="1">s += fmt.Sprintf("%s: %s\n", val.Key, valueContent)

                        // Удаляем из карты, чтобы она осталась для renderCustomFields
                        delete(valuesMap, key)</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}

// maskCardNumber маскирует номер карты, оставляя видимыми первые visibleCardDigits цифры с каждой стороны.
func maskCardNumber(number string) string <span class="cov8" title="1">{
        length := len(number)
        if length &lt; minCardLengthForMask </span><span class="cov8" title="1">{
                return "********" // Слишком короткий номер для маскирования
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s********%s", number[:visibleCardDigits], number[length-visibleCardDigits:])</span>
}

// renderCustomFields форматирует дополнительные (нестандартные) поля записи.
func renderCustomFields(valuesMap map[string]gokeepasslib.ValueData) string <span class="cov8" title="1">{
        if len(valuesMap) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">s := "\n--- Дополнительные поля ---\n"
        // Перебираем оставшиеся в карте поля
        for _, val := range valuesMap </span><span class="cov8" title="1">{
                s += fmt.Sprintf("%s: %s\n", val.Key, val.Value.Content)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// getBinariesFromDB возвращает срез бинарных данных из базы данных,
// учитывая версию формата KDBX.
// Возвращает срез и bool (true, если путь к данным корректен, даже если срез пуст).
func getBinariesFromDB(db *gokeepasslib.Database) ([]gokeepasslib.Binary, bool) <span class="cov8" title="1">{
        if db == nil || db.Content == nil || db.Header == nil </span><span class="cov0" title="0">{
                slog.Warn("Cannot get binaries: db, db.Content, or db.Header is nil")
                return nil, false
        }</span>

        <span class="cov8" title="1">if db.Header.IsKdbx4() </span><span class="cov8" title="1">{
                // KDBX v4
                if db.Content.InnerHeader == nil </span><span class="cov0" title="0">{
                        slog.Warn("Cannot get KDBX4 binaries: db.Content.InnerHeader is nil")
                        return nil, false // Структура некорректна
                }</span>
                <span class="cov8" title="1">return db.Content.InnerHeader.Binaries, true</span>
        }

        // KDBX v3 (если не KDBX4)
        <span class="cov0" title="0">if db.Content.Meta == nil </span><span class="cov0" title="0">{
                slog.Warn("Cannot get KDBX3 binaries: db.Content.Meta is nil")
                return nil, false // Структура некорректна
        }</span>
        <span class="cov0" title="0">return db.Content.Meta.Binaries, true</span>
}

// renderAttachments форматирует список вложений для отображения.
func renderAttachments(db *gokeepasslib.Database, entry gokeepasslib.Entry) string <span class="cov8" title="1">{
        if len(entry.Binaries) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">s := "\n--- Вложения ---\n"
        binaries, pathOk := getBinariesFromDB(db)

        // Определяем путь к бинарным данным в зависимости от версии KDBX
        if !pathOk </span><span class="cov0" title="0">{
                // Если структура БД некорректна, просто выводим имена без размера
                for _, binaryRef := range entry.Binaries </span><span class="cov0" title="0">{
                        s += fmt.Sprintf("- %s (размер неизвестен)\n", binaryRef.Name)
                }</span>
                <span class="cov0" title="0">return s</span>
        }

        <span class="cov8" title="1">if len(binaries) &gt; 0 </span><span class="cov8" title="1">{
                // Создаем map длин, если бинарные данные найдены
                binaryLens := make(map[int]int)
                for _, bin := range binaries </span><span class="cov8" title="1">{
                        binaryLens[bin.ID] = len(bin.Content)
                }</span>
                // Выводим вложения с размерами
                <span class="cov8" title="1">for _, binaryRef := range entry.Binaries </span><span class="cov8" title="1">{
                        if binaryLen, ok := binaryLens[binaryRef.Value.ID]; ok </span><span class="cov8" title="1">{
                                s += fmt.Sprintf("- %s (%d байт)\n", binaryRef.Name, binaryLen)
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("- %s (данные не найдены!)\n", binaryRef.Name)
                                slog.Warn("Binary content not found in DB for reference", "name", binaryRef.Name, "ref_id", binaryRef.Value.ID)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Если путь к данным корректен, но самих данных нет (например, пустая база)
                slog.Warn("No binary content found at the expected path, although DB structure seems ok.")
                for _, binaryRef := range entry.Binaries </span><span class="cov0" title="0">{
                        s += fmt.Sprintf("- %s (размер неизвестен)\n", binaryRef.Name)
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

// viewEntryDetailScreen отрисовывает экран деталей записи.
func (m *model) viewEntryDetailScreen() string <span class="cov8" title="1">{
        if m.selectedEntry == nil </span><span class="cov8" title="1">{
                return "Ошибка: запись не выбрана."
        }</span>

        <span class="cov8" title="1">s := fmt.Sprintf("Детали записи: %s\n\n", m.selectedEntry.Title())

        // Собираем все значения в map для дальнейшего использования
        valuesMap := make(map[string]gokeepasslib.ValueData)
        for _, val := range m.selectedEntry.entry.Values </span><span class="cov8" title="1">{
                valuesMap[val.Key] = val
        }</span>

        // Отображаем стандартные поля (и удаляем их из map)
        <span class="cov8" title="1">s += renderStandardFields(m.selectedEntry.entry, valuesMap) // Передаем map

        // Отображаем дополнительные поля (оставшиеся в map)
        s += renderCustomFields(valuesMap)

        // Отображаем вложения
        s += renderAttachments(m.db, m.selectedEntry.entry)

        return s</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package tui

import (
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/tobischo/gokeepasslib/v3"
        w "github.com/tobischo/gokeepasslib/v3/wrappers"
)

const (
        attachmentListHeightDivisor = 2 // Делитель для высоты списка вложений
)

// attachmentItem представляет элемент списка вложений для выбора/удаления.
// Реализует интерфейс list.Item.
type attachmentItem struct {
        name string
        id   int // ID из BinaryReference (Value.ID)
}

func (i attachmentItem) Title() string       <span class="cov8" title="1">{ return i.name }</span>
func (i attachmentItem) Description() string <span class="cov8" title="1">{ return fmt.Sprintf("ID: %d", i.id) }</span>
func (i attachmentItem) FilterValue() string <span class="cov8" title="1">{ return i.name }</span>

// prepareEditScreen инициализирует поля для экрана редактирования.
func (m *model) prepareEditScreen() <span class="cov8" title="1">{
        if m.selectedEntry == nil </span><span class="cov8" title="1">{
                return // Нечего редактировать
        }</span>

        // Создаем глубокую копию записи для редактирования
        <span class="cov8" title="1">entryCopy := deepCopyEntry(m.selectedEntry.entry)
        m.editingEntry = &amp;entryCopy

        m.editInputs = make([]textinput.Model, numEditableFields)

        // Используем константы имен полей как плейсхолдеры
        placeholders := map[int]string{
                editableFieldTitle:          fieldNameTitle,
                editableFieldUserName:       fieldNameUserName,
                editableFieldPassword:       fieldNamePassword,
                editableFieldURL:            fieldNameURL,
                editableFieldNotes:          fieldNameNotes,
                editableFieldCardNumber:     fieldNameCardNumber,
                editableFieldCardHolderName: fieldNameCardHolderName,
                editableFieldExpiryDate:     fieldNameExpiryDate,
                editableFieldCVV:            fieldNameCVV,
                editableFieldPIN:            fieldNamePIN,
        }

        for i := range numEditableFields </span><span class="cov8" title="1">{
                placeholder := placeholders[i]
                m.editInputs[i] = textinput.New()
                m.editInputs[i].Placeholder = placeholder
                // Получаем текущее значение из редактируемой записи
                m.editInputs[i].SetValue(m.editingEntry.GetContent(placeholder))

                // Настраиваем маскирование для чувствительных полей
                switch i </span>{
                case editableFieldPassword, editableFieldCVV, editableFieldPIN:<span class="cov8" title="1">
                        m.editInputs[i].EchoMode = textinput.EchoPassword</span>
                case editableFieldCardNumber:<span class="cov8" title="1"></span>
                        // TODO: Может быть, использовать EchoPassword или спец. режим?
                        // Пока оставим обычным текстом
                }

                // Убираем установку фокуса здесь
                // // Первое поле делаем активным
                // if i == m.focusedField {
                //         m.editInputs[i].Focus()
                // }
        }
        // Вызываем updateFocus после инициализации всех полей,
        // чтобы установить фокус на основе m.focusedField
        <span class="cov8" title="1">m.updateFocus()</span> // Эта функция должна вызывать Focus() / Blur() для нужных инпутов
}

// updateEntryEditScreen обрабатывает сообщения для экрана редактирования записи.
func (m *model) updateEntryEditScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                // Обработка нажатий клавиш делегируется отдельной функции
                return m.handleEditScreenKeys(msg)</span>

        default:<span class="cov0" title="0">
                // Другие сообщения (не KeyMsg) на этом экране пока не обрабатываются
                // (Логика обновления поля перенесена в handleEditScreenKeys)
                return m, nil</span>
        }
}

// handleEditScreenKeys обрабатывает нажатия клавиш на экране редактирования.
//
//nolint:gocognit,funlen // Сложность и длина будут снижены при рефакторинге
func (m *model) handleEditScreenKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case keyEsc, keyBack:<span class="cov8" title="1">
                m.state = entryDetailScreen
                m.editingEntry = nil
                m.editInputs = nil
                slog.Info("Отмена редактирования, возврат к деталям записи")
                return m, tea.ClearScreen</span>

        case "tab", "down":<span class="cov8" title="1">
                m.focusedField = (m.focusedField + 1) % numEditableFields
                cmds := m.updateFocus()
                return m, tea.Batch(cmds...)</span>

        case "shift+tab", "up":<span class="cov0" title="0">
                m.focusedField = (m.focusedField - 1 + numEditableFields) % numEditableFields
                cmds := m.updateFocus()
                return m, tea.Batch(cmds...)</span>

        case keyEnter:<span class="cov8" title="1">
                if !m.readOnlyMode </span><span class="cov8" title="1">{
                        return m.saveEntryChanges()
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "ctrl+o":<span class="cov0" title="0">
                if !m.readOnlyMode </span><span class="cov0" title="0">{
                        slog.Info("Переход к экрану ввода пути для добавления вложения")
                        m.previousScreenState = m.state
                        m.state = attachmentPathInputScreen
                        m.attachmentPathInput.Reset()
                        m.attachmentPathInput.Focus()
                        m.attachmentError = nil
                        return m, tea.Batch(textinput.Blink, tea.ClearScreen)
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "ctrl+d":<span class="cov0" title="0">
                if !m.readOnlyMode </span><span class="cov0" title="0">{
                        return m.handleAttachmentDeleteAction()
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        default:<span class="cov8" title="1">
                //nolint:nestif // Вложенность из-за readOnlyMode
                if !m.readOnlyMode </span><span class="cov8" title="1">{
                        var cmds []tea.Cmd
                        var cmd tea.Cmd

                        m.editInputs[m.focusedField], cmd = m.editInputs[m.focusedField].Update(msg)
                        cmds = append(cmds, cmd)

                        fieldName := m.editInputs[m.focusedField].Placeholder
                        newValue := m.editInputs[m.focusedField].Value()
                        found := false
                        for i := range m.editingEntry.Values </span><span class="cov8" title="1">{
                                if m.editingEntry.Values[i].Key == fieldName </span><span class="cov8" title="1">{
                                        m.editingEntry.Values[i].Value.Content = newValue
                                        if fieldName == fieldNamePassword || fieldName == fieldNameCVV || fieldName == fieldNamePIN </span><span class="cov0" title="0">{
                                                m.editingEntry.Values[i].Value.Protected = w.NewBoolWrapper(newValue != "")
                                        }</span>
                                        <span class="cov8" title="1">found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                                valueData := gokeepasslib.ValueData{
                                        Key:   fieldName,
                                        Value: gokeepasslib.V{Content: newValue},
                                }
                                if fieldName == fieldNamePassword || fieldName == fieldNameCVV || fieldName == fieldNamePIN </span><span class="cov0" title="0">{
                                        valueData.Value.Protected = w.NewBoolWrapper(newValue != "")
                                }</span>
                                <span class="cov0" title="0">m.editingEntry.Values = append(m.editingEntry.Values, valueData)</span>
                        }
                        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }
}

// handleAttachmentDeleteAction обрабатывает действие удаления вложения.
func (m *model) handleAttachmentDeleteAction() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if m.editingEntry != nil &amp;&amp; len(m.editingEntry.Binaries) &gt; 0 </span><span class="cov8" title="1">{
                slog.Info("Переход к экрану удаления вложения")
                items := make([]list.Item, len(m.editingEntry.Binaries))
                for i, binRef := range m.editingEntry.Binaries </span><span class="cov8" title="1">{
                        items[i] = attachmentItem{name: binRef.Name, id: binRef.Value.ID}
                }</span>
                <span class="cov8" title="1">m.attachmentList.SetItems(items)
                m.attachmentList.SetSize(defaultListWidth, defaultListHeight/attachmentListHeightDivisor)
                m.state = attachmentListDeleteScreen
                return m, tea.ClearScreen</span>
        }
        <span class="cov8" title="1">slog.Info("Нет вложений для удаления")
        return m, nil</span>
}

// saveEntryChanges применяет изменения из editingEntry к selectedEntry и списку.
func (m *model) saveEntryChanges() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd
        if m.selectedEntry == nil || m.editingEntry == nil </span><span class="cov0" title="0">{
                slog.Warn("Попытка сохранить изменения без выбранной или редактируемой записи")
                return m, nil // Ничего не делаем
        }</span>

        // 1. Создаем финальную обновленную запись на основе editingEntry
        <span class="cov8" title="1">finalUpdatedEntry := deepCopyEntry(*m.editingEntry) // Используем deepCopy на всякий случай
        // Обновляем время модификации
        now := time.Now()
        finalUpdatedEntry.Times.LastModificationTime = &amp;w.TimeWrapper{Time: now} // Создаем обертку и берем указатель

        // 2. Создаем новый элемент списка с обновленной записью
        newSelectedItem := entryItem{entry: finalUpdatedEntry}

        // 3. Обновляем элемент в списке list.Model
        idx := m.entryList.Index()
        updateCmd := m.entryList.SetItem(idx, newSelectedItem) // Передаем новый элемент
        cmds = append(cmds, updateCmd)

        // 4. Обновляем selectedEntry в модели, чтобы он указывал на новый элемент
        m.selectedEntry = &amp;newSelectedItem

        // 5. Возвращаемся к деталям и очищаем состояние редактирования
        m.state = entryDetailScreen
        m.editingEntry = nil
        m.editInputs = nil
        slog.Info("Изменения сохранены, возврат к деталям записи")
        // Добавим ClearScreen к другим командам
        cmds = append(cmds, tea.ClearScreen)
        return m, tea.Batch(cmds...)</span>
}

// viewEntryEditScreen отрисовывает экран редактирования записи.
func (m *model) viewEntryEditScreen() string <span class="cov0" title="0">{
        var s strings.Builder
        s.WriteString("Редактирование записи: " + m.editingEntry.GetTitle() + "\n\n")

        // Отображаем все поля ввода, полагаясь на их метод View()
        for _, input := range m.editInputs </span><span class="cov0" title="0">{
                s.WriteString(input.View() + "\n")
        }</span>

        // Отображаем вложения
        <span class="cov0" title="0">s.WriteString("\n--- Вложения ---\n")
        if len(m.editingEntry.Binaries) == 0 </span><span class="cov0" title="0">{
                s.WriteString("(Нет вложений)\n")
        }</span> else<span class="cov0" title="0"> {
                for i, binaryRef := range m.editingEntry.Binaries </span><span class="cov0" title="0">{
                        // TODO: Добавить индикатор выбора для удаления?
                        s.WriteString(fmt.Sprintf(" [%d] %s\n", i, binaryRef.Name))
                }</span>
        }

        <span class="cov0" title="0">return s.String()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tui

import (
        "fmt"
        "log/slog"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"

        // Убедимся, что импорт есть.
        "github.com/maynagashev/gophkeeper/client/internal/api"
        "github.com/maynagashev/gophkeeper/client/internal/kdbx"
)

// Добавляем константу для статуса.
const (
        statusNotLoggedIn = "Не выполнен"
)

// updateEntryListScreen обрабатывает сообщения для экрана списка записей.
func (m *model) updateEntryListScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmd tea.Cmd
        var cmds []tea.Cmd

        // Сначала обновляем список
        m.entryList, cmd = m.entryList.Update(msg)
        cmds = append(cmds, cmd)

        // Обработка клавиш для экрана списка
        //nolint:nestif // Вложенность из-за разных клавиш
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyQuit:<span class="cov0" title="0">
                        // Выход по 'q', если не активен режим фильтрации
                        if m.entryList.FilterState() == list.Unfiltered </span><span class="cov0" title="0">{
                                return m, tea.Quit
                        }</span>
                case keyEnter:<span class="cov8" title="1">
                        selectedItem := m.entryList.SelectedItem()
                        if selectedItem != nil </span><span class="cov8" title="1">{
                                // Убеждаемся, что это наш тип entryItem
                                if item, isEntryItem := selectedItem.(entryItem); isEntryItem </span><span class="cov8" title="1">{
                                        m.selectedEntry = &amp;item
                                        m.state = entryDetailScreen
                                        slog.Info("Переход к деталям записи", "title", item.Title())
                                        cmds = append(cmds, tea.ClearScreen)
                                }</span>
                        }
                case keyAdd:<span class="cov8" title="1">
                        // Переход к добавлению новой записи (только если не Read-Only)
                        if !m.readOnlyMode </span><span class="cov8" title="1">{
                                m.prepareAddScreen()
                                m.state = entryAddScreen
                                slog.Info("Переход к добавлению новой записи")
                                return m, tea.ClearScreen
                        }</span>
                case "s":<span class="cov0" title="0">
                        m.state = syncServerScreen
                        // Добавляем ClearScreen при переходе
                        return m, tea.ClearScreen</span>
                case "l":<span class="cov0" title="0">
                        // TODO: Проверить, настроен ли URL и валиден ли токен
                        // Если URL не настроен -&gt; serverUrlInputScreen
                        // Если токен есть, но невалиден -&gt; loginScreen
                        // Если токен валиден -&gt; может быть, просто показать статус?
                        // Пока просто переходим к выбору
                        m.state = loginRegisterChoiceScreen
                        return m, nil</span>
                }
        }
        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// _handleAuthLoadError обрабатывает ошибку загрузки Auth данных.
func (m *model) _handleAuthLoadError(errLoad error, urlFromFlag bool) <span class="cov8" title="1">{
        slog.Error("Ошибка загрузки Auth данных из KDBX", "error", errLoad)
        if !urlFromFlag </span><span class="cov8" title="1">{
                m.serverURL = ""
                m.apiClient = nil
        }</span>
        <span class="cov8" title="1">m.authToken = ""
        m.loginStatus = statusNotLoggedIn + " (ошибка загрузки)"</span>
}

// _handleAuthLoadSuccess обрабатывает успешную загрузку Auth данных.
func (m *model) _handleAuthLoadSuccess(loadedURL, loadedToken string, urlFromFlag bool) <span class="cov8" title="1">{
        if urlFromFlag </span><span class="cov8" title="1">{
                // URL задан флагом, загружаем только токен
                m.authToken = loadedToken
                slog.Info("URL сервера задан флагом, загружен только токен из KDBX", "token_found", m.authToken != "")
        }</span> else<span class="cov8" title="1"> {
                // URL не задан флагом, используем загруженный URL
                m.serverURL = loadedURL
                m.authToken = loadedToken
                if m.serverURL != "" </span><span class="cov8" title="1">{
                        m.apiClient = api.NewHTTPClient(m.serverURL)
                        slog.Info("URL сервера загружен из KDBX, создан API клиент", "url", m.serverURL, "token_found", m.authToken != "")
                }</span> else<span class="cov8" title="1"> {
                        m.apiClient = nil
                        slog.Info("URL сервера не задан и не найден в KDBX.")
                }</span>
        }

        // Обновляем статус входа
        <span class="cov8" title="1">if m.authToken != "" </span><span class="cov8" title="1">{
                m.loginStatus = "Вход выполнен (сессия загружена)"
        }</span> else<span class="cov8" title="1"> {
                m.loginStatus = statusNotLoggedIn
        }</span>
}

// handleDBOpenedMsg обрабатывает сообщение об успешном открытии базы.
func (m *model) handleDBOpenedMsg(msg dbOpenedMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        slog.Debug("handleDBOpenedMsg: Начало")
        m.db = msg.db
        m.err = nil
        prevState := m.state
        m.state = entryListScreen
        slog.Info("База KDBX успешно открыта", "path", m.kdbxPath)

        // --- Обновленная логика загрузки Auth данных ---
        // Определяем, был ли URL задан через флаг (т.е. apiClient уже инициализирован)
        urlFromFlag := m.serverURL != "" &amp;&amp; m.apiClient != nil
        slog.Debug("Проверка URL из флага", "urlFromFlag", urlFromFlag, "initialURL", m.serverURL)

        loadedURL, loadedToken, errLoad := kdbx.LoadAuthData(m.db)
        // Вызываем соответствующие хелперы
        if errLoad != nil </span><span class="cov0" title="0">{
                m._handleAuthLoadError(errLoad, urlFromFlag)
        }</span> else<span class="cov8" title="1"> {
                m._handleAuthLoadSuccess(loadedURL, loadedToken, urlFromFlag)
        }</span>

        // Устанавливаем токен в API клиенте, если клиент существует
        <span class="cov8" title="1">if m.apiClient != nil </span><span class="cov0" title="0">{
                m.apiClient.SetAuthToken(m.authToken) // m.authToken будет либо загруженным, либо пустым
                slog.Debug("Установлен токен в API клиенте после загрузки/проверки KDBX", "token_set", m.authToken != "")
        }</span> else<span class="cov8" title="1"> {
                // Эта ситуация возможна, если URL не задан ни флагом, ни в KDBX
                slog.Warn("API клиент не инициализирован (URL не задан), токен не установлен.")
        }</span>

        // --- Существующий код для заполнения списка ---
        <span class="cov8" title="1">entries := kdbx.GetAllEntries(m.db)
        slog.Debug("Записи, полученные из KDBX", "count", len(entries))

        items := make([]list.Item, len(entries))
        for i, entry := range entries </span><span class="cov8" title="1">{
                items[i] = entryItem{entry: entry}
        }</span>

        <span class="cov8" title="1">slog.Debug("Элементы, подготовленные для списка", "count", len(items))
        // Используем m.entryList.SetItems, а не listCmd, так как команда теперь не используется
        _ = m.entryList.SetItems(items) // Команду от SetItems пока игнорируем

        slog.Debug("Элементы в списке после SetItems", "count", len(m.entryList.Items()))

        m.entryList.SetWidth(defaultListWidth)
        m.entryList.SetHeight(defaultListHeight)
        m.entryList.Title = fmt.Sprintf("Записи в '%s' (%d)", m.kdbxPath, len(items))

        // --- Команды для возврата ---
        dbOpenedCmds := []tea.Cmd{}
        if prevState != entryListScreen </span><span class="cov0" title="0">{
                dbOpenedCmds = append(dbOpenedCmds, tea.ClearScreen)
        }</span>

        <span class="cov8" title="1">slog.Debug("handleDBOpenedMsg: Конец, m.db обновлен")
        return m, tea.Batch(dbOpenedCmds...)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package tui

import (
        tea "github.com/charmbracelet/bubbletea"
)

// updateLoginScreen обрабатывает ввод данных для входа.
func (m *model) updateLoginScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        loginAction := func() (tea.Model, tea.Cmd) </span><span class="cov8" title="1">{
                username := m.loginUsernameInput.Value()
                password := m.loginPasswordInput.Value()
                // Вызываем команду для выполнения входа
                cmd := m.makeLoginCmd(username, password)
                // Можно добавить сообщение о начале процесса входа
                m, statusCmd := m.setStatusMessage("Выполняется вход...")
                return m, tea.Batch(cmd, statusCmd) // Возвращаем команду входа и команду статуса
        }</span>

        <span class="cov8" title="1">return m.handleCredentialsInput(
                msg,
                &amp;m.loginUsernameInput,
                &amp;m.loginPasswordInput,
                &amp;m.loginRegisterFocusedField,
                loginAction,               // Передаем нашу функцию loginAction
                loginRegisterChoiceScreen, // Возвращаемся к выбору при Esc
        )</span>
}

// viewLoginScreen отображает экран ввода данных для входа.
func (m *model) viewLoginScreen() string <span class="cov8" title="1">{
        // Используем общую функцию
        return m.viewCredentialsScreen(
                "Вход в учетную запись",
                "Нажмите Enter для входа, Esc для возврата",
                m.loginUsernameInput,
                m.loginPasswordInput,
        )
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package tui

import (
        "strings"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// updateLoginRegisterChoiceScreen обрабатывает выбор между входом и регистрацией.
func (m *model) updateLoginRegisterChoiceScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case "r", "R":<span class="cov8" title="1">
                        m.state = registerScreen
                        m.registerUsernameInput.Focus()
                        m.loginRegisterFocusedField = 0
                        return m, tea.Batch(textinput.Blink, tea.ClearScreen)</span>
                case "l", "L":<span class="cov8" title="1">
                        m.state = loginScreen
                        m.loginUsernameInput.Focus()
                        m.loginRegisterFocusedField = 0
                        return m, tea.Batch(textinput.Blink, tea.ClearScreen)</span>
                case keyEsc, keyBack:<span class="cov8" title="1">
                        m.state = syncServerScreen // Возвращаемся на экран синхронизации и сервера
                        return m, nil</span>
                }
        }
        // Если сообщение не было обработано (не keyMsg или не нужная клавиша)
        <span class="cov8" title="1">return m, nil</span>
}

// viewLoginRegisterChoiceScreen отображает экран выбора входа или регистрации.
func (m *model) viewLoginRegisterChoiceScreen() string <span class="cov8" title="1">{
        var b strings.Builder

        titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#FAFAFA"))
        focusedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("205")) // Пурпурный
        subtleStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))  // Серый

        b.WriteString(titleStyle.Render("Настройка сервера") + "\n\n")
        b.WriteString("Сервер настроен: " + m.serverURL + "\n\n") // Показываем настроенный URL
        b.WriteString("Выберите действие:\n")
        b.WriteString("- Регистрация нового пользователя " + focusedStyle.Render("(R)") + "\n")
        b.WriteString("- Вход с существующими данными " + focusedStyle.Render("(L)") + "\n\n")
        b.WriteString(subtleStyle.Render("Нажмите Esc для возврата"))

        return b.String()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package tui

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/maynagashev/gophkeeper/client/internal/kdbx"
        "github.com/tobischo/gokeepasslib/v3"
        "github.com/tobischo/gokeepasslib/v3/wrappers"
)

// var errorStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("9")) // Красный цвет для ошибок (перенесено в view)

// updateNewKdbxPasswordScreen обрабатывает сообщения для экрана ввода пароля нового KDBX.
//
//nolint:gocognit,funlen // Сложность и длина будут снижены при рефакторинге
func (m *model) updateNewKdbxPasswordScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd
        var cmd tea.Cmd

        //nolint:nestif // Сложность вложенности будет снижена при рефакторинге
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case "ctrl+c", keyEsc:<span class="cov8" title="1"> // Выход из приложения, если мы еще не создали файл
                        return m, tea.Quit</span>

                case keyTab, keyShiftTab, keyUp, keyDown:<span class="cov8" title="1">
                        m.newPasswordFocusedField = (m.newPasswordFocusedField + 1) % numNewPasswordFields // Переключаем фокус
                        m.confirmPasswordError = ""                                                        // Сбрасываем ошибку

                        if m.newPasswordFocusedField == 0 </span><span class="cov8" title="1">{
                                m.newPasswordInput1.Focus()
                                m.newPasswordInput2.Blur()
                                cmd = textinput.Blink
                        }</span> else<span class="cov8" title="1"> {
                                m.newPasswordInput1.Blur()
                                m.newPasswordInput2.Focus()
                                cmd = textinput.Blink
                        }</span>
                        <span class="cov8" title="1">cmds = append(cmds, cmd)
                        return m, tea.Batch(cmds...)</span>

                case keyEnter:<span class="cov8" title="1">
                        // Если фокус на первом поле, переключаем на второе (если первый пароль не пуст)
                        if m.newPasswordFocusedField == 0 </span><span class="cov8" title="1">{
                                if m.newPasswordInput1.Value() == "" </span><span class="cov8" title="1">{
                                        m.confirmPasswordError = "Пароль не может быть пустым!"
                                        return m, nil
                                }</span>
                                // Переключаем фокус на второе поле
                                <span class="cov8" title="1">m.newPasswordFocusedField = 1
                                m.confirmPasswordError = "" // Сбрасываем ошибку
                                m.newPasswordInput1.Blur()
                                m.newPasswordInput2.Focus()
                                cmd = textinput.Blink
                                cmds = append(cmds, cmd)
                                return m, tea.Batch(cmds...)</span>
                        }

                        // Если фокус на втором поле, проверяем и создаем базу
                        <span class="cov8" title="1">pass1 := m.newPasswordInput1.Value()
                        pass2 := m.newPasswordInput2.Value()

                        if pass1 == "" </span><span class="cov0" title="0">{
                                m.confirmPasswordError = "Пароль не может быть пустым!"
                                return m, nil
                        }</span>
                        <span class="cov8" title="1">if pass1 != pass2 </span><span class="cov8" title="1">{
                                m.confirmPasswordError = "Пароли не совпадают!"
                                m.newPasswordInput1.SetValue("") // Очищаем поля
                                m.newPasswordInput2.SetValue("")
                                m.newPasswordInput1.Focus() // Возвращаем фокус на первое поле
                                m.newPasswordInput2.Blur()
                                m.newPasswordFocusedField = 0
                                return m, textinput.Blink
                        }</span>

                        // Пароли совпадают, создаем новую базу
                        <span class="cov8" title="1">m.confirmPasswordError = "" // Сбрасываем ошибку
                        m.password = pass1          // Сохраняем пароль в модели

                        slog.Info("Пароли совпадают, создаем новую базу KDBX", "path", m.kdbxPath)
                        // Создаем пустую базу данных KDBX 4.0 с помощью опции
                        m.db = gokeepasslib.NewDatabase(gokeepasslib.WithDatabaseKDBXVersion4())

                        // InnerHeader и Root теперь должны быть инициализированы этой опцией,
                        // но на всякий случай проверим и инициализируем Root, если нужно.
                        if m.db.Content.Root == nil </span><span class="cov0" title="0">{
                                m.db.Content.Root = &amp;gokeepasslib.RootData{
                                        Groups: []gokeepasslib.Group{
                                                {
                                                        Name: "General",
                                                        UUID: gokeepasslib.NewUUID(),
                                                        Times: gokeepasslib.TimeData{
                                                                CreationTime: &amp;wrappers.TimeWrapper{
                                                                        Time:      time.Now(),
                                                                        Formatted: false,
                                                                },
                                                                LastModificationTime: &amp;wrappers.TimeWrapper{
                                                                        Time:      time.Now(),
                                                                        Formatted: false,
                                                                },
                                                        },
                                                },
                                        },
                                }
                        }</span>

                        // Используем имя файла (без расширения) как имя базы данных
                        <span class="cov8" title="1">baseName := filepath.Base(m.kdbxPath)
                        dbName := strings.TrimSuffix(baseName, filepath.Ext(baseName))
                        m.db.Content.Meta.DatabaseName = dbName
                        // Устанавливаем Generator (опционально, WithKDBX4 может уже это делать)
                        m.db.Content.Meta.Generator = "GophKeeper"

                        // Устанавливаем пароль
                        m.db.Credentials = gokeepasslib.NewPasswordCredentials(m.password)

                        // Сохраняем новую базу
                        file, err := os.Create(m.kdbxPath)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Error("Ошибка создания файла KDBX", "path", m.kdbxPath, "error", err)
                                m.confirmPasswordError = fmt.Sprintf("Ошибка создания файла: %v", err)
                                return m, nil
                        }</span>
                        <span class="cov8" title="1">defer file.Close() // Используем defer для гарантированного закрытия

                        encoder := gokeepasslib.NewEncoder(file)
                        // УДАЛЕНО: Применение заголовков к кодировщику - делается через NewDatabase
                        if errEncode := encoder.Encode(m.db); errEncode != nil </span><span class="cov0" title="0">{
                                slog.Error("Ошибка записи в новый файл KDBX", "path", m.kdbxPath, "error", errEncode)
                                m.confirmPasswordError = fmt.Sprintf("Ошибка записи в файл: %v", errEncode)
                                return m, nil
                        }</span>

                        <span class="cov8" title="1">slog.Info("Новый файл KDBX успешно создан и сохранен", "path", m.kdbxPath)
                        // Переходим к списку
                        m.state = entryListScreen

                        // Загружаем записи из свежесозданной базы данных
                        entries := kdbx.GetAllEntries(m.db)
                        slog.Debug("Записи, полученные из новой KDBX", "count", len(entries))
                        items := make([]list.Item, len(entries))
                        for i, entry := range entries </span><span class="cov8" title="1">{
                                items[i] = entryItem{entry: entry}
                        }</span>
                        <span class="cov8" title="1">slog.Debug("Элементы, подготовленные для списка", "count", len(items))
                        m.entryList.SetItems(items) // Устанавливаем элементы в список

                        // Устанавливаем размер списка явно (как при открытии существующей базы)
                        m.entryList.SetWidth(defaultListWidth)
                        m.entryList.SetHeight(defaultListHeight)

                        // Обновляем заголовок списка, включая количество элементов
                        m.entryList.Title = fmt.Sprintf("Записи в '%s' (%d)", m.kdbxPath, len(items))
                        return m, tea.ClearScreen</span> // Очищаем экран перед показом списка
                }

                // Обновляем активное поле ввода, если это не спец. клавиша
                <span class="cov8" title="1">if m.newPasswordFocusedField == 0 </span><span class="cov8" title="1">{
                        m.newPasswordInput1, cmd = m.newPasswordInput1.Update(msg)
                }</span> else<span class="cov8" title="1"> {
                        m.newPasswordInput2, cmd = m.newPasswordInput2.Update(msg)
                }</span>
                <span class="cov8" title="1">cmds = append(cmds, cmd)</span>
        } // else if msg.(type) is not tea.KeyMsg, do nothing? Maybe return m, nil?

        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// viewNewKdbxPasswordScreen отрисовывает экран ввода пароля для нового KDBX.
func (m *model) viewNewKdbxPasswordScreen() string <span class="cov8" title="1">{
        // Определяем стиль ошибки локально
        errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("9"))

        s := "Создание нового файла KDBX: " + m.kdbxPath + "\n\n"

        // Добавляем индикатор фокуса
        focusIndicator1 := "  "
        focusIndicator2 := "  "
        if m.newPasswordFocusedField == 0 </span><span class="cov8" title="1">{
                focusIndicator1 = "&gt; "
        }</span> else<span class="cov8" title="1"> {
                focusIndicator2 = "&gt; "
        }</span>

        <span class="cov8" title="1">s += focusIndicator1 + m.newPasswordInput1.View() + "\n"
        s += focusIndicator2 + m.newPasswordInput2.View() + "\n\n"

        if m.confirmPasswordError != "" </span><span class="cov8" title="1">{
                s += errorStyle.Render(m.confirmPasswordError) + "\n"
        }</span>

        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package tui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

// updatePasswordInputScreen обрабатывает сообщения для экрана ввода пароля.
func (m *model) updatePasswordInputScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmd tea.Cmd
        var cmds []tea.Cmd

        // Сначала обновляем поле ввода
        m.passwordInput, cmd = m.passwordInput.Update(msg)
        cmds = append(cmds, cmd)

        // Обработка клавиш для экрана ввода пароля
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                // Если была ошибка, любое нажатие ее скрывает
                if m.err != nil </span><span class="cov8" title="1">{
                        m.err = nil
                        m.passwordInput.Focus() // Возвращаем фокус
                        cmds = append(cmds, textinput.Blink)
                        // Не обрабатываем другие клавиши в этом цикле
                }</span> else<span class="cov8" title="1"> {
                        switch keyMsg.String() </span>{
                        case keyEnter:<span class="cov8" title="1">
                                password := m.passwordInput.Value()
                                m.passwordInput.Blur()
                                m.passwordInput.Reset()
                                // Сохраняем пароль в модели перед отправкой команды
                                m.password = password
                                cmds = append(cmds, openKdbxCmd(m.kdbxPath, password))</span>
                        case keyEsc, keyCtrlC:<span class="cov8" title="1"> // Используем константу
                                m.state = welcomeScreen
                                m.passwordInput.Blur()
                                m.passwordInput.Reset()
                                m.password = "" // Сбрасываем пароль
                                cmds = append(cmds, tea.ClearScreen)</span>
                        }
                }
        }
        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// viewPasswordInputScreen отрисовывает экран ввода пароля.
func (m *model) viewPasswordInputScreen() string <span class="cov8" title="1">{
        var s strings.Builder
        s.WriteString("Введите мастер-пароль для " + m.kdbxPath + ":\n")
        s.WriteString(m.passwordInput.View() + "\n\n")
        if m.err != nil </span><span class="cov8" title="1">{
                errMsgStr := fmt.Sprintf("\nОшибка: %s\n\n(Нажмите любую клавишу для продолжения)", m.err)
                return s.String() + errMsgStr // Возвращаем основной текст + текст ошибки
        }</span>
        <span class="cov8" title="1">return s.String()</span>
}

// handleErrorMsg обрабатывает сообщение об ошибке.
func (m *model) handleErrorMsg(msg errMsg) tea.Model /*, tea.Cmd */ <span class="cov8" title="1">{
        // Устанавливаем статус ошибки и возвращаемся к экрану ввода пароля
        m.err = msg.err // Сохраняем ошибку в модели
        m.state = passwordInputScreen
        m.passwordInput.Focus()
        return m // , nil // Больше не возвращаем команду
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package tui

import (
        tea "github.com/charmbracelet/bubbletea"
)

// updateRegisterScreen обрабатывает ввод данных для регистрации.
func (m *model) updateRegisterScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        registerAction := func() (tea.Model, tea.Cmd) </span><span class="cov8" title="1">{
                username := m.registerUsernameInput.Value()
                password := m.registerPasswordInput.Value()
                // Вызываем команду для выполнения регистрации (создадим её позже)
                cmd := m.makeRegisterCmd(username, password)
                m, statusCmd := m.setStatusMessage("Выполняется регистрация...")
                return m, tea.Batch(cmd, statusCmd)
        }</span>

        <span class="cov8" title="1">return m.handleCredentialsInput(
                msg,
                &amp;m.registerUsernameInput,
                &amp;m.registerPasswordInput,
                &amp;m.loginRegisterFocusedField,
                registerAction,
                loginRegisterChoiceScreen, // Возвращаемся к выбору при Esc
        )</span>
}

// viewRegisterScreen отображает экран ввода данных для регистрации.
func (m *model) viewRegisterScreen() string <span class="cov8" title="1">{
        // Используем общую функцию
        return m.viewCredentialsScreen(
                "Регистрация новой учетной записи",
                "Нажмите Enter для регистрации, Esc для возврата",
                m.registerUsernameInput,
                m.registerPasswordInput,
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package tui

import (
        "fmt"
        "log/slog"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/maynagashev/gophkeeper/client/internal/api"
)

// updateServerURLInputScreen обрабатывает ввод URL сервера.
func (m *model) updateServerURLInputScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Обрабатываем Esc и Enter, остальное передаем в textinput
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyEsc:<span class="cov8" title="1">
                        m.state = syncServerScreen // Возвращаемся к меню синхронизации
                        return m, nil</span>
                case keyEnter:<span class="cov8" title="1">
                        newURL := m.serverURLInput.Value()
                        if newURL == "" </span><span class="cov8" title="1">{
                                newURL = m.serverURLInput.Placeholder // Используем плейсхолдер если пусто
                        }</span>
                        // TODO: Добавить валидацию URL?
                        <span class="cov8" title="1">m.serverURL = newURL
                        // Сбрасываем статус, т.к. URL изменился
                        m.loginStatus = "Не выполнен"
                        m.authToken = ""
                        m.apiClient = api.NewHTTPClient(newURL) // Пересоздаем клиент с новым URL
                        slog.Info("URL сервера обновлен", "url", newURL)
                        // Переходим к выбору логина/регистрации
                        m.state = loginRegisterChoiceScreen
                        // Добавляем ClearScreen для очистки артефактов
                        return m, tea.ClearScreen</span>
                }
        }
        // Обновляем поле ввода
        <span class="cov8" title="1">newInput, inputCmd := m.serverURLInput.Update(msg)
        m.serverURLInput = newInput
        // Возвращаем обновленную модель и команду от textinput
        return m, inputCmd</span>
}

// viewServerURLInputScreen отображает экран ввода URL сервера.
func (m *model) viewServerURLInputScreen() string <span class="cov8" title="1">{
        return fmt.Sprintf("Введите URL сервера:\n%s", m.serverURLInput.View())
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package tui

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/maynagashev/gophkeeper/client/internal/kdbx"
)

// --- Константы для ID пунктов меню синхронизации --- //.
const (
        syncMenuIDConfigureURL  = "configure_url"
        syncMenuIDLoginRegister = "login_register"
        syncMenuIDSyncNow       = "sync_now"
        syncMenuIDViewVersions  = "view_versions"
        syncMenuIDLogout        = "logout"
)

// --- Тип для элементов меню синхронизации --- //

// syncMenuItem представляет элемент в меню синхронизации.
type syncMenuItem struct {
        title string
        id    string // Идентификатор для обработки выбора
}

func (i syncMenuItem) Title() string       <span class="cov8" title="1">{ return i.title }</span>
func (i syncMenuItem) Description() string <span class="cov8" title="1">{ return "" }</span> // Описание не нужно
func (i syncMenuItem) FilterValue() string <span class="cov8" title="1">{ return i.title }</span>

// --- Функции экрана --- //

// viewSyncServerScreen отображает экран "Синхронизация и Сервер".
func (m *model) viewSyncServerScreen() string <span class="cov8" title="1">{
        serverURLText := m.serverURL
        if serverURLText == "" </span><span class="cov8" title="1">{
                serverURLText = "Не настроен"
        }</span>

        <span class="cov8" title="1">statusInfo := fmt.Sprintf(
                "URL Сервера: %s\nСтатус входа: %s\nПоследняя синх.: %s\n",
                serverURLText,
                m.loginStatus,
                m.lastSyncStatus,
        )

        // Объединяем информацию о статусе и РЕНДЕР МЕНЮ
        // Добавляем перенос строки между ними для четкого разделения.
        return fmt.Sprintf("%s\n\n%s", statusInfo, m.syncServerMenu.View())</span>
}

// handleSyncMenuConfigureURL обрабатывает выбор пункта "Настроить URL сервера".
func (m *model) handleSyncMenuConfigureURL() tea.Cmd <span class="cov8" title="1">{
        m.serverURLInput.Reset()
        m.serverURLInput.Placeholder = "https://..."
        m.serverURLInput.Focus()
        if m.serverURL != "" </span><span class="cov8" title="1">{
                m.serverURLInput.SetValue(m.serverURL)
        }</span>
        <span class="cov8" title="1">m.state = serverURLInputScreen
        return textinput.Blink</span>
}

// handleSyncMenuLoginRegister обрабатывает выбор пункта "Войти / Зарегистрироваться".
func (m *model) handleSyncMenuLoginRegister() tea.Cmd <span class="cov8" title="1">{
        if m.serverURL == "" </span><span class="cov8" title="1">{
                _, cmd := m.setStatusMessage("Сначала настройте URL сервера")
                return cmd
        }</span>
        <span class="cov8" title="1">m.loginUsernameInput.Focus()
        m.loginPasswordInput.Blur()
        m.loginRegisterFocusedField = 0
        m.state = loginRegisterChoiceScreen
        return textinput.Blink</span>
}

// handleSyncMenuSyncNow обрабатывает выбор пункта "Синхронизировать сейчас".
func (m *model) handleSyncMenuSyncNow() tea.Cmd <span class="cov8" title="1">{
        if m.authToken == "" </span><span class="cov8" title="1">{
                _, cmd := m.setStatusMessage("Необходимо войти перед синхронизацией")
                return cmd
        }</span>
        <span class="cov8" title="1">newM, statusCmd := m.setStatusMessage("Запуск синхронизации...")
        mModel, ok := newM.(*model)
        if !ok </span><span class="cov0" title="0">{
                slog.Error("Неожиданный тип модели после setStatusMessage")
                return tea.Batch(statusCmd, func() tea.Msg </span><span class="cov0" title="0">{
                        return errMsg{err: errors.New("внутренняя ошибка типа модели")}
                }</span>)
        }
        <span class="cov8" title="1">syncCmd := startSyncCmd(mModel)
        return tea.Batch(statusCmd, syncCmd)</span>
}

// handleSyncMenuViewVersions обрабатывает выбор пункта "Просмотреть версии".
func (m *model) handleSyncMenuViewVersions() tea.Cmd <span class="cov8" title="1">{
        if m.authToken == "" </span><span class="cov8" title="1">{
                _, cmd := m.setStatusMessage("Необходимо войти для просмотра версий")
                return cmd
        }</span>
        <span class="cov8" title="1">m.state = versionListScreen
        m.loadingVersions = true
        return tea.Batch(tea.ClearScreen, loadVersionsCmd(m))</span>
}

// handleSyncMenuLogout обрабатывает выбор пункта "Выйти на сервере".
func (m *model) handleSyncMenuLogout() tea.Cmd <span class="cov8" title="1">{
        if m.authToken == "" </span><span class="cov8" title="1">{
                _, cmd := m.setStatusMessage("Вы не авторизованы")
                return cmd
        }</span>
        <span class="cov8" title="1">oldToken := m.authToken
        m.authToken = ""
        m.loginStatus = statusNotLoggedIn
        if m.apiClient != nil </span><span class="cov8" title="1">{
                m.apiClient.SetAuthToken("")
        }</span>
        <span class="cov8" title="1">var saveCmd tea.Cmd
        if m.db != nil </span><span class="cov8" title="1">{
                errSave := kdbx.SaveAuthData(m.db, m.serverURL, "")
                if errSave != nil </span><span class="cov0" title="0">{
                        slog.Error("Ошибка сохранения пустого токена в KDBX при выходе", "error", errSave)
                        _, saveCmd = m.setStatusMessage("Ошибка сохранения данных при выходе")
                }</span> else<span class="cov8" title="1"> {
                        slog.Info("Локальный токен очищен и сохранен в KDBX.")
                        _, saveCmd = m.setStatusMessage("Успешно вышли")
                }</span>
        } else<span class="cov8" title="1"> {
                slog.Warn("Не удалось сохранить пустой токен в KDBX при выходе: база не загружена.")
                _, saveCmd = m.setStatusMessage("Успешно вышли (локально)")
        }</span>
        <span class="cov8" title="1">slog.Info("Выполнен выход", "token_existed", oldToken != "")
        return saveCmd</span>
}

// Меняем возвращаемый тип на *model.
func (m *model) updateSyncServerScreen(msg tea.Msg) (*model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd
        var listCmd tea.Cmd

        // Обновляем список меню сначала
        m.syncServerMenu, listCmd = m.syncServerMenu.Update(msg)
        cmds = append(cmds, listCmd)

        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyEnter:<span class="cov8" title="1">
                        // Обработка выбора пункта меню
                        cmd := m.handleSyncMenuAction()
                        cmds = append(cmds, cmd)</span>
                        // Может потребоваться ClearScreen в зависимости от действия
                case keyEsc, keyBack:<span class="cov8" title="1">
                        m.state = entryListScreen
                        return m, tea.ClearScreen</span>
                // Добавляем отдельный case для Backspace
                case "backspace":<span class="cov8" title="1">
                        m.state = entryListScreen
                        return m, tea.ClearScreen</span>
                }
        }

        // Возвращаем указатель на модель
        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// handleSyncMenuAction обрабатывает действие выбора в меню синхронизации.
func (m *model) handleSyncMenuAction() tea.Cmd <span class="cov8" title="1">{
        selectedItem, ok := m.syncServerMenu.SelectedItem().(syncMenuItem)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch selectedItem.id </span>{
        case syncMenuIDConfigureURL:<span class="cov8" title="1">
                return m.handleSyncMenuConfigureURL()</span>
        case syncMenuIDLoginRegister:<span class="cov8" title="1">
                return m.handleSyncMenuLoginRegister()</span>
        case syncMenuIDSyncNow:<span class="cov8" title="1">
                return m.handleSyncMenuSyncNow()</span>
        case syncMenuIDViewVersions:<span class="cov8" title="1">
                return m.handleSyncMenuViewVersions()</span>
        case syncMenuIDLogout:<span class="cov8" title="1">
                return m.handleSyncMenuLogout()</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package tui

import (
        "bytes"
        "context"
        "errors"
        "io"
        "strings"
        "testing"
        "time"

        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/maynagashev/gophkeeper/models"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/mock"
        "github.com/stretchr/testify/require"
        "github.com/tobischo/gokeepasslib/v3"
)

// ScreenTestSuite содержит общую инфраструктуру для тестирования экранов.
type ScreenTestSuite struct {
        Model *model
        Mocks struct {
                APIClient *ScreenTestMockAPIClient
        }
}

// ScreenTestMockAPIClient - мок для API клиента, реализующий интерфейс api.Client.
type ScreenTestMockAPIClient struct {
        mock.Mock
}

// Login мокирует метод Login.
func (m *ScreenTestMockAPIClient) Login(ctx context.Context, username, password string) (string, error) <span class="cov8" title="1">{
        args := m.Called(ctx, username, password)
        return args.String(0), args.Error(1)
}</span>

// Register мокирует метод Register.
func (m *ScreenTestMockAPIClient) Register(ctx context.Context, username, password string) error <span class="cov8" title="1">{
        args := m.Called(ctx, username, password)
        return args.Error(0)
}</span>

// Константы для индексов аргументов mock.
const (
        mockErrorIndex = 2 // Индекс ошибки в аргументах mock
)

// GetVaultMetadata мокирует метод GetVaultMetadata.
func (m *ScreenTestMockAPIClient) GetVaultMetadata(ctx context.Context) (*models.VaultVersion, error) <span class="cov8" title="1">{
        args := m.Called(ctx)
        err := args.Error(1)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if args.Get(0) == nil </span><span class="cov0" title="0">{
                // Если ошибки нет, но и объекта нет, возвращаем nil, nil (или можно паниковать, если это не ожидаемый сценарий)
                return nil, nil //nolint:nilnil // Мок может быть настроен вернуть nil, nil
        }</span>
        // Проверяем ошибку перед приведением типа
        <span class="cov8" title="1">v, ok := args.Get(0).(*models.VaultVersion) // Используем проверку типа
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("mock GetVaultMetadata: unexpected type returned")
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

// UploadVault мокирует метод UploadVault.
func (m *ScreenTestMockAPIClient) UploadVault(
        ctx context.Context,
        data io.Reader,
        size int64,
        contentModifiedAt time.Time,
) error <span class="cov8" title="1">{
        args := m.Called(ctx, data, size, contentModifiedAt)
        return args.Error(0)
}</span>

// DownloadVault мокирует метод DownloadVault.
func (m *ScreenTestMockAPIClient) DownloadVault(ctx context.Context) (io.ReadCloser, *models.VaultVersion, error) <span class="cov8" title="1">{
        args := m.Called(ctx)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, nil, args.Error(mockErrorIndex)
        }</span>
        <span class="cov8" title="1">if args.Get(1) == nil </span><span class="cov8" title="1">{
                readCloser, ok := args.Get(0).(io.ReadCloser)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, args.Error(mockErrorIndex)
                }</span>
                <span class="cov8" title="1">return readCloser, nil, args.Error(mockErrorIndex)</span>
        }

        <span class="cov8" title="1">readCloser, ok1 := args.Get(0).(io.ReadCloser)
        if !ok1 </span><span class="cov0" title="0">{
                return nil, nil, args.Error(mockErrorIndex)
        }</span>

        <span class="cov8" title="1">version, ok2 := args.Get(1).(*models.VaultVersion)
        if !ok2 </span><span class="cov0" title="0">{
                return readCloser, nil, args.Error(mockErrorIndex)
        }</span>

        <span class="cov8" title="1">return readCloser, version, args.Error(mockErrorIndex)</span>
}

// ListVersions мокирует метод ListVersions.
func (m *ScreenTestMockAPIClient) ListVersions(
        ctx context.Context,
        limit,
        offset int,
) ([]models.VaultVersion, int64, error) <span class="cov8" title="1">{
        args := m.Called(ctx, limit, offset)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, 0, args.Error(mockErrorIndex)
        }</span>

        <span class="cov8" title="1">versions, ok1 := args.Get(0).([]models.VaultVersion)
        if !ok1 </span><span class="cov0" title="0">{
                return nil, 0, args.Error(mockErrorIndex)
        }</span>

        <span class="cov8" title="1">count, ok2 := args.Get(1).(int64)
        if !ok2 </span><span class="cov0" title="0">{
                return versions, 0, args.Error(mockErrorIndex)
        }</span>

        <span class="cov8" title="1">return versions, count, args.Error(mockErrorIndex)</span>
}

// RollbackToVersion мокирует метод RollbackToVersion.
func (m *ScreenTestMockAPIClient) RollbackToVersion(ctx context.Context, versionID int64) error <span class="cov8" title="1">{
        args := m.Called(ctx, versionID)
        return args.Error(0)
}</span>

// SetAuthToken мокирует метод SetAuthToken.
func (m *ScreenTestMockAPIClient) SetAuthToken(token string) <span class="cov8" title="1">{
        m.Called(token)
}</span>

// NewScreenTestSuite создает новую тестовую среду для экранов.
func NewScreenTestSuite() *ScreenTestSuite <span class="cov8" title="1">{
        s := &amp;ScreenTestSuite{}

        // Инициализируем модель
        s.Model = &amp;model{
                // Базовые поля модели
                db:           nil,
                kdbxPath:     "/tmp/test.kdbx",
                readOnlyMode: false,
                password:     "test-password",

                // Текстовые поля
                loginUsernameInput:    textinput.New(),
                loginPasswordInput:    textinput.New(),
                registerUsernameInput: textinput.New(),
                registerPasswordInput: textinput.New(),
                serverURLInput:        textinput.New(),
                // Инициализируем поля, используемые в тестах
                passwordInput:       textinput.New(), // Поле для ввода пароля KDBX
                attachmentPathInput: textinput.New(), // Поле для ввода пути вложения

                // Компоненты UI
                entryList:   list.New([]list.Item{}, list.NewDefaultDelegate(), 0, 0),
                versionList: list.New([]list.Item{}, list.NewDefaultDelegate(), 0, 0),
        }

        // Инициализируем моки
        s.Mocks.APIClient = new(ScreenTestMockAPIClient)
        s.Model.apiClient = s.Mocks.APIClient

        // Инициализируем карту помощи (копируем из Start() в tui.go)
        s.Model.helpTextMap = map[screenState]string{
                welcomeScreen:              "(Enter - продолжить, Ctrl+C/q - выход)",
                passwordInputScreen:        "(Enter - подтвердить, " + keyCtrlC + " - выход)", // Используем константу
                newKdbxPasswordScreen:      "(Tab - сменить поле, Enter - создать, Esc/" + keyCtrlC + " - выход)",
                entryListScreen:            "(↑/↓, Enter - детали, / - поиск, a - доб, s - синхр, l - логин, Ctrl+S - сохр, q - вых)",
                entryDetailScreen:          "(e - ред., Ctrl+S - сохр., Esc/b - назад)",
                entryEditScreen:            "(Tab/↑/↓, Enter - сохр., Esc - отмена, ^O - влож+, ^D - влож-)",
                entryAddScreen:             "(Tab/↑/↓, Enter - доб., ^O - влож+, Esc - отмена)",
                attachmentListDeleteScreen: "(↑/↓ - навигация, Enter/d - удалить, Esc/b - отмена)",
                attachmentPathInputScreen:  "(Enter - подтвердить, Esc - отмена)",
                syncServerScreen:           "(↑/↓ - навигация, Enter - выбрать, Esc/b - назад)",
                serverURLInputScreen:       "(Enter - подтвердить, Esc - назад)",
                loginRegisterChoiceScreen:  "(R - регистрация, L - вход, Esc/b - назад)",
                loginScreen:                "(Tab - след. поле, Enter - войти, Esc - назад)",
                registerScreen:             "(Tab - след. поле, Enter - зарегистрироваться, Esc - назад)",
                versionListScreen:          "(↑/↓ - навигация, Enter - откатить, Esc/b - назад, r - обновить)",
        }

        return s
}</span>

// WithServerURL устанавливает URL сервера в модели.
func (s *ScreenTestSuite) WithServerURL(url string) *ScreenTestSuite <span class="cov8" title="1">{
        s.Model.serverURL = url
        return s
}</span>

// WithAuthToken устанавливает токен авторизации в модели.
func (s *ScreenTestSuite) WithAuthToken(token string) *ScreenTestSuite <span class="cov8" title="1">{
        s.Model.authToken = token
        return s
}</span>

// WithDatabase устанавливает базу данных в модели.
func (s *ScreenTestSuite) WithDatabase(db *gokeepasslib.Database) *ScreenTestSuite <span class="cov8" title="1">{
        s.Model.db = db
        return s
}</span>

// WithState устанавливает состояние экрана в модели.
func (s *ScreenTestSuite) WithState(state screenState) *ScreenTestSuite <span class="cov8" title="1">{
        s.Model.state = state
        return s
}</span>

// SimulateKeyPress симулирует нажатие клавиши.
func (s *ScreenTestSuite) SimulateKeyPress(key tea.KeyType) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        msg := tea.KeyMsg{Type: key}
        return s.Model.Update(msg)
}</span>

// SimulateKeyRune симулирует ввод символа.
func (s *ScreenTestSuite) SimulateKeyRune(r rune) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        msg := tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{r}}
        return s.Model.Update(msg)
}</span>

// ExecuteCmd выполняет команду и возвращает сообщение.
func (s *ScreenTestSuite) ExecuteCmd(_ context.Context, cmd tea.Cmd) tea.Msg <span class="cov8" title="1">{
        if cmd == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Вызов команды. Контекст пока не используется здесь напрямую,
        // но может понадобиться командам в будущем.
        <span class="cov8" title="1">return cmd()</span>
}

// AssertViewContains проверяет, что View() модели содержит указанный текст.
func (s *ScreenTestSuite) AssertViewContains(t *testing.T, substring string) <span class="cov8" title="1">{
        view := s.Model.View()
        assert.Contains(t, view, substring, "View должен содержать указанный текст")
}</span>

// AssertState проверяет, что состояние модели соответствует ожидаемому.
func (s *ScreenTestSuite) AssertState(t *testing.T, expected screenState) <span class="cov8" title="1">{
        assert.Equal(t, expected, s.Model.state, "Состояние модели должно быть %s, но получено %s", expected, s.Model.state)
}</span>

// toModel безопасно приводит tea.Model к *model.
func toModel(t *testing.T, m tea.Model) *model <span class="cov8" title="1">{
        require.NotNil(t, m, "Модель не должна быть nil")
        result, ok := m.(*model)
        require.True(t, ok, "Модель должна быть типа *model")
        return result
}</span>

// CaptureView выполняет команду и возвращает результат View().
func (s *ScreenTestSuite) CaptureView(t *testing.T, cmd tea.Cmd) string <span class="cov8" title="1">{
        if cmd != nil </span><span class="cov8" title="1">{
                msg := cmd()
                newModel, _ := s.Model.Update(msg)
                s.Model = toModel(t, newModel)
        }</span>
        <span class="cov8" title="1">return s.Model.View()</span>
}

// CaptureOutput выполняет последовательность команд и возвращает финальный View.
func (s *ScreenTestSuite) CaptureOutput(t *testing.T, cmds ...tea.Cmd) string <span class="cov8" title="1">{
        for _, cmd := range cmds </span><span class="cov8" title="1">{
                if cmd == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">msg := cmd()
                newModel, _ := s.Model.Update(msg)
                s.Model = toModel(t, newModel)</span>
        }
        <span class="cov8" title="1">return s.Model.View()</span>
}

// CreateBasicTestDB создает простую тестовую базу данных.
func CreateBasicTestDB() *gokeepasslib.Database <span class="cov8" title="1">{
        db := gokeepasslib.NewDatabase()
        db.Content = gokeepasslib.NewContent()

        rootGroup := gokeepasslib.Group{
                Name: "Root",
        }

        // Создаем пару записей для тестирования
        entry1 := gokeepasslib.NewEntry()
        entry1.Values = append(entry1.Values, gokeepasslib.ValueData{
                Key:   "Title",
                Value: gokeepasslib.V{Content: "Тестовая запись 1"},
        })
        entry1.Values = append(entry1.Values, gokeepasslib.ValueData{
                Key:   "UserName",
                Value: gokeepasslib.V{Content: "user1"},
        })
        entry1.Values = append(entry1.Values, gokeepasslib.ValueData{
                Key:   "Password",
                Value: gokeepasslib.V{Content: "pass1"},
        })

        entry2 := gokeepasslib.NewEntry()
        entry2.Values = append(entry2.Values, gokeepasslib.ValueData{
                Key:   "Title",
                Value: gokeepasslib.V{Content: "Тестовая запись 2"},
        })

        rootGroup.Entries = append(rootGroup.Entries, entry1, entry2)
        db.Content.Root = &amp;gokeepasslib.RootData{
                Groups: []gokeepasslib.Group{rootGroup},
        }

        return db
}</span>

// MockResponse создает ответ для мока API клиента.
type MockResponse struct {
        Success bool
        Token   string
        Error   error
}

// SetupMockAPILogin настраивает мок API клиента для метода Login.
func (s *ScreenTestSuite) SetupMockAPILogin(username, password string, response MockResponse) *ScreenTestSuite <span class="cov8" title="1">{
        if response.Success </span><span class="cov8" title="1">{
                s.Mocks.APIClient.On("Login", mock.Anything, username, password).
                        Return(response.Token, nil).Once()
        }</span> else<span class="cov8" title="1"> {
                s.Mocks.APIClient.On("Login", mock.Anything, username, password).
                        Return("", response.Error).Once()
        }</span>
        <span class="cov8" title="1">return s</span>
}

// SetupMockAPIRegister настраивает мок API клиента для метода Register.
func (s *ScreenTestSuite) SetupMockAPIRegister(username, password string, response MockResponse) *ScreenTestSuite <span class="cov8" title="1">{
        if response.Success </span><span class="cov8" title="1">{
                s.Mocks.APIClient.On("Register", mock.Anything, username, password).
                        Return(nil).Once()
        }</span> else<span class="cov8" title="1"> {
                s.Mocks.APIClient.On("Register", mock.Anything, username, password).
                        Return(response.Error).Once()
        }</span>
        <span class="cov8" title="1">return s</span>
}

// RenderScreen выполняет рендеринг View() для тестирования отображения.
func (s *ScreenTestSuite) RenderScreen() string <span class="cov8" title="1">{
        var buf bytes.Buffer

        // Получаем View текущей модели
        view := s.Model.View()

        // Очищаем ANSI-последовательности для упрощения тестирования
        // Это простая очистка, для более точной можно использовать библиотеки
        cleanView := strings.ReplaceAll(view, "\033[", "")
        cleanView = strings.ReplaceAll(cleanView, "\r", "")

        buf.WriteString(cleanView)
        return buf.String()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package tui

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "github.com/charmbracelet/bubbles/list"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/maynagashev/gophkeeper/client/internal/api"
        "github.com/maynagashev/gophkeeper/models"
)

// --- Сообщения для работы с версиями --- //

// Константы для работы с версиями.
const (
        defaultVersionListLimit = 50 // Добавлено для mnd
)

// versionsLoadedMsg сообщает о завершении загрузки списка версий.
type versionsLoadedMsg struct {
        versions         []models.VaultVersion
        currentVersionID int64
}

// versionsLoadErrorMsg сообщает об ошибке при загрузке списка версий.
type versionsLoadErrorMsg struct {
        err error
}

// rollbackSuccessMsg сообщает об успешном откате к выбранной версии.
type rollbackSuccessMsg struct {
        versionID int64
}

// rollbackErrorMsg сообщает об ошибке при откате к выбранной версии.
type rollbackErrorMsg struct {
        err error
}

// --- Команды для работы с версиями --- //

// loadVersionsCmd загружает список версий с сервера.
func loadVersionsCmd(m *model) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                if m.apiClient == nil </span><span class="cov8" title="1">{
                        return versionsLoadErrorMsg{err: errors.New("API клиент не инициализирован")}
                }</span>

                <span class="cov8" title="1">if m.authToken == "" </span><span class="cov8" title="1">{
                        return versionsLoadErrorMsg{err: errors.New("требуется авторизация")}
                }</span>

                <span class="cov8" title="1">ctx := context.Background()
                // Вызываем обновленную ListVersions
                versions, currentID, err := m.apiClient.ListVersions(ctx, defaultVersionListLimit, 0)
                if err != nil </span><span class="cov8" title="1">{
                        // Проверяем на ошибку авторизации
                        if errors.Is(err, api.ErrAuthorization) </span><span class="cov8" title="1">{
                                slog.Error("Ошибка загрузки списка версий: ошибка авторизации")
                                return versionsLoadErrorMsg{err: api.ErrAuthorization} // Возвращаем именно ErrAuthorization
                        }</span>
                        <span class="cov8" title="1">slog.Error("Ошибка загрузки списка версий", "error", err)
                        return versionsLoadErrorMsg{err: err}</span>
                }

                <span class="cov8" title="1">slog.Info("Список версий успешно загружен", "count", len(versions), "current_id", currentID)
                return versionsLoadedMsg{versions: versions, currentVersionID: currentID}</span>
        }
}

// rollbackToVersionCmd выполняет откат к выбранной версии.
func rollbackToVersionCmd(ctx context.Context, m *model, versionID int64) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                if m.apiClient == nil </span><span class="cov8" title="1">{
                        return rollbackErrorMsg{err: errors.New("API клиент не инициализирован")}
                }</span>

                <span class="cov8" title="1">if m.authToken == "" </span><span class="cov8" title="1">{
                        return rollbackErrorMsg{err: errors.New("требуется авторизация")}
                }</span>

                // Используем переданный контекст
                <span class="cov8" title="1">err := m.apiClient.RollbackToVersion(ctx, versionID)
                if err != nil </span><span class="cov8" title="1">{
                        slog.Error("Ошибка отката к версии", "version_id", versionID, "error", err)
                        return rollbackErrorMsg{err: err}
                }</span>

                <span class="cov8" title="1">slog.Info("Успешный откат к версии", "version_id", versionID)
                return rollbackSuccessMsg{versionID: versionID}</span>
        }
}

// --- Функции обработки экрана версий --- //

// handleVersionRollbackConfirm обрабатывает ввод в режиме подтверждения отката.
func (m *model) handleVersionRollbackConfirm(ctx context.Context, keyMsg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch keyMsg.String() </span>{
        case keyEnter:<span class="cov8" title="1">
                // Подтверждение отката
                if m.selectedVersionForRollback != nil </span><span class="cov8" title="1">{
                        m.confirmRollback = false
                        m.rollbackError = nil
                        // Передаем полученный контекст в команду
                        return m, tea.Batch(tea.ClearScreen, rollbackToVersionCmd(ctx, m, m.selectedVersionForRollback.ID))
                }</span>
        case keyEsc, keyBack:<span class="cov8" title="1">
                // Отмена отката
                m.confirmRollback = false
                m.selectedVersionForRollback = nil
                // Добавляем ClearScreen
                return m, tea.ClearScreen</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// handleVersionRollbackError обрабатывает ввод в режиме отображения ошибки отката.
func (m *model) handleVersionRollbackError(keyMsg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if keyMsg.String() == keyEsc || keyMsg.String() == keyBack || keyMsg.String() == keyEnter </span><span class="cov8" title="1">{
                m.rollbackError = nil
                // Добавляем ClearScreen
                return m, tea.ClearScreen
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// handleVersionListKeys обрабатывает основные клавиши на экране списка версий.
func (m *model) handleVersionListKeys(keyMsg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch keyMsg.String() </span>{
        case keyEnter:<span class="cov8" title="1">
                // Выбор версии для отката
                selectedItem := m.versionList.SelectedItem()
                if item, itemOk := selectedItem.(versionItem); itemOk </span><span class="cov8" title="1">{ // Используем itemOk
                        if item.isCurrent </span><span class="cov8" title="1">{
                                // Нельзя откатиться к текущей версии
                                return m.setStatusMessage("Это уже текущая версия")
                        }</span>
                        <span class="cov8" title="1">m.selectedVersionForRollback = &amp;item.version
                        m.confirmRollback = true
                        // Добавляем ClearScreen при переходе к подтверждению
                        return m, tea.ClearScreen</span>
                }
        case keyEsc, keyBack:<span class="cov8" title="1">
                // Возврат к экрану синхронизации
                m.state = syncServerScreen
                return m, tea.ClearScreen</span>
        case "r":<span class="cov8" title="1">
                // Обновление списка версий
                m.loadingVersions = true
                return m, loadVersionsCmd(m)</span>
        case "l":<span class="cov8" title="1">
                // Переход к экрану логина/регистрации
                m.state = loginRegisterChoiceScreen
                return m, tea.ClearScreen</span>
        }
        <span class="cov8" title="1">return m, nil</span> // Клавиша не обработана здесь
}

// viewVersionListScreen отображает экран со списком версий.
func (m *model) viewVersionListScreen() string <span class="cov8" title="1">{
        if m.loadingVersions </span><span class="cov8" title="1">{
                return "Загрузка списка версий..."
        }</span>

        <span class="cov8" title="1">if m.confirmRollback &amp;&amp; m.selectedVersionForRollback != nil </span><span class="cov8" title="1">{
                // Показываем экран подтверждения отката
                confirmMsg := fmt.Sprintf(
                        "Вы уверены, что хотите откатиться к версии #%d?\n\n"+
                                "Время изменения: %s\n\n"+
                                "Enter - подтвердить, Esc - отменить",
                        m.selectedVersionForRollback.ID,
                        formatTime(m.selectedVersionForRollback.ContentModifiedAt),
                )
                return confirmMsg
        }</span>

        <span class="cov8" title="1">if m.rollbackError != nil </span><span class="cov8" title="1">{
                // Показываем ошибку отката
                return fmt.Sprintf("Ошибка отката: %v\n\nНажмите Esc для возврата к списку версий", m.rollbackError)
        }</span>

        <span class="cov8" title="1">if len(m.versions) == 0 </span><span class="cov8" title="1">{
                return "История версий пуста.\n\nПосле успешной синхронизации здесь появятся версии."
        }</span>

        // Обычный показ списка версий
        <span class="cov8" title="1">return m.versionList.View()</span>
}

// updateVersionListScreen обрабатывает сообщения для экрана списка версий.
func (m *model) updateVersionListScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmd tea.Cmd
        var cmds []tea.Cmd

        // Обработка сообщений клавиатуры
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                // Если показывается экран подтверждения
                if m.confirmRollback </span><span class="cov8" title="1">{
                        // Передаем контекст в обработчик подтверждения
                        // Используем Background(), т.к. Update не имеет контекста
                        return m.handleVersionRollbackConfirm(context.Background(), keyMsg)
                }</span>

                // Если показывается ошибка отката
                <span class="cov8" title="1">if m.rollbackError != nil </span><span class="cov8" title="1">{
                        return m.handleVersionRollbackError(keyMsg)
                }</span>

                // Стандартная обработка клавиш для списка версий
                <span class="cov8" title="1">model, keyCmd := m.handleVersionListKeys(keyMsg)
                // Если клавиша была обработана в handleVersionListKeys, она вернет команду
                if keyCmd != nil </span><span class="cov8" title="1">{
                        return model, keyCmd
                }</span>
                // Если клавиша не была обработана выше, передаем ее списку
        }

        // Обработка обновлений списка (скроллинг и т.д.)
        <span class="cov0" title="0">m.versionList, cmd = m.versionList.Update(msg)
        cmds = append(cmds, cmd)
        return m, tea.Batch(cmds...)</span>
}

// handleVersionsLoadedMsg обрабатывает сообщение о загруженных версиях.
func handleVersionsLoadedMsg(m *model, msg versionsLoadedMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.loadingVersions = false
        m.versions = msg.versions

        // Преобразуем модели в версии для списка и отмечаем текущую
        var items []list.Item
        currentVersionID := msg.currentVersionID // Используем ID из сообщения

        // Пытаемся определить текущую версию, если ID из сообщения 0 или его нет (для обратной совместимости?)
        if currentVersionID == 0 &amp;&amp; m.serverMeta != nil </span><span class="cov8" title="1">{
                currentVersionID = m.serverMeta.ID
                slog.Warn("currentVersionID из API = 0, используем ID из serverMeta", "serverMeta.ID", currentVersionID)
        }</span>

        <span class="cov8" title="1">for _, v := range m.versions </span><span class="cov8" title="1">{
                items = append(items, versionItem{
                        version:   v,
                        isCurrent: v.ID == currentVersionID,
                })
        }</span>

        // Обновляем список и получаем команду от него
        <span class="cov8" title="1">listCmd := m.versionList.SetItems(items) // Не игнорируем команду

        // Оборачиваем сообщение ClearScreen в команду
        clearCmd := tea.ClearScreen

        // Добавляем ClearScreen для очистки артефактов
        return m, tea.Batch(listCmd, clearCmd)</span>
}

// handleVersionsLoadErrorMsg обрабатывает ошибку загрузки версий.
func handleVersionsLoadErrorMsg(m *model, msg versionsLoadErrorMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.loadingVersions = false
        // Проверяем, является ли ошибка ошибкой авторизации
        if errors.Is(msg.err, api.ErrAuthorization) </span><span class="cov8" title="1">{
                // Не меняем состояние здесь, т.к. мы уже на экране версий,
                // но даем пользователю понять, что делать (нажать 'l')
                newM, statusCmd := m.setStatusMessage("Ошибка авторизации. Токен истек? Попробуйте войти заново (L).")
                return newM, tea.Batch(statusCmd, tea.ClearScreen) // Добавляем ClearScreen
        }</span>
        // Иначе показываем общую ошибку
        // Возвращаем результат setStatusMessage, который включает команду
        <span class="cov8" title="1">newM, statusCmd := m.setStatusMessage(fmt.Sprintf("Ошибка загрузки версий: %v", msg.err))
        // Добавляем ClearScreen и сюда
        return newM, tea.Batch(statusCmd, tea.ClearScreen)</span>
}

// handleRollbackSuccessMsg обрабатывает успешный откат к версии.
func handleRollbackSuccessMsg(m *model, msg rollbackSuccessMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // После успешного отката нужно принудительно скачать новую текущую версию
        statusText := fmt.Sprintf("Откат к версии #%d успешен. Загрузка...", msg.versionID)
        newM, statusCmd := m.setStatusMessage(statusText)

        // Заменяем startSyncCmd на downloadVaultCmd для принудительного скачивания
        return newM, tea.Batch(statusCmd, tea.ClearScreen, downloadVaultCmd(m))
}</span>

// handleRollbackErrorMsg обрабатывает ошибку отката.
func handleRollbackErrorMsg(m *model, msg rollbackErrorMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Проверяем, является ли ошибка ошибкой авторизации
        if errors.Is(msg.err, api.ErrAuthorization) </span><span class="cov8" title="1">{
                m.state = loginRegisterChoiceScreen // Переходим на экран выбора входа/регистрации
                newM, statusCmd := m.setStatusMessage("Сессия истекла. Пожалуйста, войдите снова (L).")
                return newM, tea.Batch(statusCmd, tea.ClearScreen)
        }</span>
        // Иначе устанавливаем ошибку для отображения на экране версий
        <span class="cov8" title="1">m.rollbackError = msg.err
        // Добавляем ClearScreen при показе ошибки
        return m, tea.ClearScreen</span>
}

// Вспомогательная функция для форматирования времени.
func formatTime(t *time.Time) string <span class="cov8" title="1">{
        if t == nil </span><span class="cov0" title="0">{
                return "неизвестно"
        }</span>
        <span class="cov8" title="1">return t.Format("2006-01-02 15:04:05")</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package tui

import (
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

// updateWelcomeScreen обрабатывает сообщения для экрана приветствия.
func (m *model) updateWelcomeScreen(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd
        if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov8" title="1">{
                switch keyMsg.String() </span>{
                case keyQuit:<span class="cov8" title="1">
                        return m, tea.Quit</span>
                case keyEnter:<span class="cov8" title="1">
                        m.state = passwordInputScreen
                        m.passwordInput.Focus()
                        cmds = append(cmds, textinput.Blink, tea.ClearScreen)</span>
                }
        }
        <span class="cov8" title="1">return m, tea.Batch(cmds...)</span>
}

// viewWelcomeScreen отрисовывает приветственный экран.
func (m *model) viewWelcomeScreen() string <span class="cov8" title="1">{
        return "Добро пожаловать в GophKeeper!\n\nНажмите Enter для продолжения..."
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package tui

import (
        "fmt"
        "log/slog"
        "os"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/gofrs/flock"

        "github.com/maynagashev/gophkeeper/client/internal/api" // Импортируем пакет API клиента
        // Импортируем пакет models для использования в debug info.
)

const (
        statusMessageTimeout     = 2 * time.Second         // Время отображения статусных сообщений
        defaultServerURL         = "http://localhost:8080" // Временный URL сервера по умолчанию
        helpStatusHeightOffset   = 2                       // Высота строки помощи и статуса
        docStyleMarginVertical   = 1
        docStyleMarginHorizontal = 2
)

// Init - команда, выполняемая при запуске приложения.
func (m *model) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

// setStatusMessage устанавливает статусное сообщение и запускает таймер для его очистки.
func (m *model) setStatusMessage(status string) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.savingStatus = status
        // Если таймер уже есть, останавливаем его
        if m.statusTimer != nil </span><span class="cov0" title="0">{
                m.statusTimer.Stop()
                // Мы не можем повторно использовать старый таймер, поэтому обнуляем
                m.statusTimer = nil
        }</span>
        // Запускаем команду для очистки статуса через заданное время
        <span class="cov8" title="1">cmd := clearStatusCmd(statusMessageTimeout)
        // Примечание: Мы не сохраняем сам таймер, так как tea.Tick управляет им.
        // Если нужно будет отменять таймер до его срабатывания, понадобится другой подход.
        return m, cmd</span>
}

// getMainContentView возвращает основное содержимое для текущего состояния.
func (m *model) getMainContentView() string <span class="cov8" title="1">{
        switch m.state </span>{
        case welcomeScreen:<span class="cov8" title="1">
                return m.viewWelcomeScreen()</span>
        case passwordInputScreen:<span class="cov8" title="1">
                return m.viewPasswordInputScreen()</span>
        case newKdbxPasswordScreen:<span class="cov0" title="0">
                return m.viewNewKdbxPasswordScreen()</span>
        case entryListScreen:<span class="cov8" title="1">
                return m.entryList.View()</span>
        case entryDetailScreen:<span class="cov0" title="0">
                return m.viewEntryDetailScreen()</span>
        case entryEditScreen:<span class="cov0" title="0">
                return m.viewEntryEditScreen()</span>
        case entryAddScreen:<span class="cov0" title="0">
                return m.viewEntryAddScreen()</span>
        case attachmentListDeleteScreen:<span class="cov0" title="0">
                return m.viewAttachmentListDeleteScreen()</span>
        case attachmentPathInputScreen:<span class="cov0" title="0">
                return m.viewAttachmentPathInputScreen()</span>
        case syncServerScreen:<span class="cov0" title="0">
                return m.viewSyncServerScreen()</span>
        case serverURLInputScreen:<span class="cov0" title="0">
                return m.viewServerURLInputScreen()</span>
        case loginRegisterChoiceScreen:<span class="cov0" title="0">
                return m.viewLoginRegisterChoiceScreen()</span>
        case loginScreen:<span class="cov0" title="0">
                return m.viewLoginScreen()</span>
        case registerScreen:<span class="cov0" title="0">
                return m.viewRegisterScreen()</span>
        case versionListScreen:<span class="cov0" title="0">
                return m.viewVersionListScreen()</span>
        default:<span class="cov0" title="0">
                return "Неизвестное состояние!"</span>
        }
}

// Helper function to get the main content and help string based on the state.
func (m *model) getContentAndHelp() (string, string) <span class="cov8" title="1">{
        mainContent := m.getMainContentView()
        // Используем карту из модели
        help, ok := m.helpTextMap[m.state]
        if !ok </span><span class="cov0" title="0">{
                help = "Unknown state" // Default help for unknown state
                if m.debugMode </span><span class="cov0" title="0">{
                        help = fmt.Sprintf("State: %s", m.state.String()) // More informative for debug
                }</span>
        }
        <span class="cov8" title="1">return mainContent, help</span>
}

// getDBModTimeString возвращает отформатированную строку времени модификации для БД.
func (m *model) getDBModTimeString() string <span class="cov0" title="0">{
        // Предполагаем, что db, Content и Root проверены перед вызовом
        if len(m.db.Content.Root.Groups) == 0 </span><span class="cov0" title="0">{
                return "&lt;not set&gt;" // No groups to get time from
        }</span>
        <span class="cov0" title="0">rootGroup := &amp;m.db.Content.Root.Groups[0]
        if rootGroup.Times.LastModificationTime != nil </span><span class="cov0" title="0">{
                return rootGroup.Times.LastModificationTime.Time.Format(time.RFC3339) + " (group0 mod)"
        }</span>
        <span class="cov0" title="0">if rootGroup.Times.CreationTime != nil </span><span class="cov0" title="0">{
                return rootGroup.Times.CreationTime.Time.Format(time.RFC3339) + " (group0 creation)"
        }</span>
        <span class="cov0" title="0">return "&lt;not set&gt;"</span>
}

// getDBDebugInfo генерирует отладочную информацию, связанную с базой данных.
func (m *model) getDBDebugInfo() string <span class="cov0" title="0">{
        if m.db == nil </span><span class="cov0" title="0">{
                return " [DB: not loaded]\n"
        }</span>
        <span class="cov0" title="0">if m.db.Content == nil || m.db.Content.Root == nil || m.db.Content.Meta == nil </span><span class="cov0" title="0">{
                return " [DB: Content, Root or Meta missing]\n"
        }</span>

        <span class="cov0" title="0">var dbDebugInfo strings.Builder
        dbDebugInfo.WriteString(fmt.Sprintf(" [DB Name: %s]\n", m.db.Content.Meta.DatabaseName))
        modTimeStr := m.getDBModTimeString()
        dbDebugInfo.WriteString(fmt.Sprintf(" [DB ModTime: %s]\n", modTimeStr))
        return dbDebugInfo.String()</span>
}

// Helper function to generate the debug info string.
func (m *model) getDebugInfoString() string <span class="cov0" title="0">{
        var debugInfo strings.Builder
        debugInfo.WriteString(fmt.Sprintf(" [State: %s]\n", m.state.String()))
        debugInfo.WriteString(fmt.Sprintf(" [URL: %s]\n", m.serverURL))
        debugInfo.WriteString(fmt.Sprintf(" [Token: %s]\n", m.authToken)) // Keep showing token in debug
        debugInfo.WriteString(fmt.Sprintf(" [Lock Acquired: %t]\n", m.lockAcquired))

        // Добавляем информацию о БД через helper
        dbDebugInfo := m.getDBDebugInfo()
        debugInfo.WriteString(dbDebugInfo)

        return debugInfo.String()
}</span>

// View отрисовывает пользовательский интерфейс.
func (m *model) View() string <span class="cov8" title="1">{
        mainContent, help := m.getContentAndHelp()

        // --- Формируем подвал (статус + отладка) --- //
        var footer strings.Builder

        // Добавляем статус, если он есть
        readOnlyIndicator := ""
        if m.readOnlyMode </span><span class="cov0" title="0">{
                readOnlyIndicator = " [Read-Only]"
        }</span>
        <span class="cov8" title="1">displayStatus := m.savingStatus != "" || m.readOnlyMode
        if displayStatus </span><span class="cov0" title="0">{
                footer.WriteString("\n") // Перенос перед статусом
                footer.WriteString(m.savingStatus)
                footer.WriteString(readOnlyIndicator)
        }</span>

        // Добавляем отладку, если включен режим
        <span class="cov8" title="1">if m.debugMode </span><span class="cov0" title="0">{
                // Убедимся, что help для неизвестного состояния установлен, если нужно
                if help == "Unknown state" </span><span class="cov0" title="0">{
                        help = fmt.Sprintf("State: %s", m.state.String())
                }</span>
                // Добавляем разделитель и отладку
                <span class="cov0" title="0">footer.WriteString("\n\n---\nОтладка:\n") // Двойной перенос перед отладкой
                footer.WriteString(m.getDebugInfoString())</span>
        }

        // Собираем финальный вывод
        <span class="cov8" title="1">styledContent := m.docStyle.Render(mainContent)
        // Сначала основной контент, потом помощь, потом весь подвал
        return fmt.Sprintf("%s\n%s%s", styledContent, help, footer.String())</span>
}

// Start запускает TUI приложение.
func Start(kdbxPath string, debugMode bool, serverURL string) <span class="cov0" title="0">{
        // --- Инициализация API клиента ---
        var apiClient api.Client // Объявляем переменную
        if serverURL != "" </span><span class="cov0" title="0">{     // Создаем клиент, только если URL не пустой
                apiClient = api.NewHTTPClient(serverURL)
                slog.Info("API клиент инициализирован", "baseURL", serverURL)
        }</span> else<span class="cov0" title="0"> {
                slog.Warn("URL сервера не указан (--server-url), функции API будут недоступны.")
                // apiClient остается nil
        }</span>

        // Создаем начальную модель, передавая флаг
        <span class="cov0" title="0">m := initModel(kdbxPath, debugMode, serverURL, apiClient)

        // --- Инициализация helpTextMap ---
        m.helpTextMap = map[screenState]string{
                welcomeScreen:              "(Enter - продолжить, Ctrl+C/q - выход)",
                passwordInputScreen:        "(Enter - подтвердить, Ctrl+C - выход)",
                newKdbxPasswordScreen:      "(Tab - сменить поле, Enter - создать, Esc/Ctrl+C - выход)",
                entryListScreen:            "(↑/↓, Enter - детали, / - поиск, a - доб, s - синхр, l - логин, Ctrl+S - сохр, q - вых)",
                entryDetailScreen:          "(e - ред., Ctrl+S - сохр., Esc/b - назад)",
                entryEditScreen:            "(Tab/↑/↓, Enter - сохр., Esc - отмена, ^O - влож+, ^D - влож-)",
                entryAddScreen:             "(Tab/↑/↓, Enter - доб., ^O - влож+, Esc - отмена)",
                attachmentListDeleteScreen: "(↑/↓ - навигация, Enter/d - удалить, Esc/b - отмена)",
                attachmentPathInputScreen:  "(Enter - подтвердить, Esc - отмена)",
                syncServerScreen:           "(↑/↓ - навигация, Enter - выбрать, Esc/b - назад)",
                serverURLInputScreen:       "(Enter - подтвердить, Esc - назад)",
                loginRegisterChoiceScreen:  "(R - регистрация, L - вход, Esc/b - назад)",
                loginScreen:                "(Tab - след. поле, Enter - войти, Esc - назад)",
                registerScreen:             "(Tab - след. поле, Enter - зарегистрироваться, Esc - назад)",
                versionListScreen:          "(↑/↓ - навигация, Enter - откатить, Esc/b - назад, r - обновить)",
        }

        // --- Реализация flock ---
        lockPath := kdbxPath + ".lock"
        m.fileLock = flock.New(lockPath)
        var flockErr error
        m.lockAcquired, flockErr = m.fileLock.TryLock()

        if flockErr != nil </span><span class="cov0" title="0">{
                // Критическая ошибка при попытке блокировки
                slog.Error("Критическая ошибка при попытке блокировки файла", "lockPath", lockPath, "error", flockErr)
                fmt.Fprintf(os.Stderr, "Ошибка блокировки файла %s: %v\n", lockPath, flockErr)
                // Попробуем разблокировать перед выходом
                _ = m.fileLock.Unlock()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if m.lockAcquired </span><span class="cov0" title="0">{
                slog.Info("Эксклюзивная блокировка файла получена.", "lockPath", lockPath)
                // Регистрируем разблокировку при выходе ИЗ ФУНКЦИИ START
                defer func() </span><span class="cov0" title="0">{
                        if errUnlock := m.fileLock.Unlock(); errUnlock != nil </span><span class="cov0" title="0">{
                                slog.Error("Ошибка при снятии блокировки файла", "lockPath", lockPath, "error", errUnlock)
                        }</span> else<span class="cov0" title="0"> {
                                slog.Info("Блокировка файла снята.", "lockPath", lockPath)
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                m.readOnlyMode = true
                slog.Warn("Блокировка не получена (файл используется?). Read-Only.", "lockPath", lockPath)
        }</span>
        // --- Конец реализации flock ---

        // Проверяем, существует ли файл KDBX
        <span class="cov0" title="0">if _, errStat := os.Stat(m.kdbxPath); os.IsNotExist(errStat) </span><span class="cov0" title="0">{
                // Файл не существует, переходим на экран создания пароля
                slog.Info("Файл KDBX не найден, переходим к созданию нового.", "path", m.kdbxPath)
                m.state = newKdbxPasswordScreen // Используем константу в нижнем регистре
                m.newPasswordInput1.Focus()
                m.newPasswordInput2.Blur()
        }</span> else<span class="cov0" title="0"> if errStat != nil </span><span class="cov0" title="0">{
                // Другая ошибка при доступе к файлу
                slog.Error("Ошибка при проверке файла KDBX", "path", m.kdbxPath, "error", errStat)
                fmt.Fprintf(os.Stderr, "Ошибка доступа к файлу %s: %v\n", m.kdbxPath, errStat)
                // Разблокируем файл перед выходом
                if m.lockAcquired </span><span class="cov0" title="0">{
                        _ = m.fileLock.Unlock()
                }</span>
                //nolint:gocritic // Unlock вызывается вручную перед выходом
                <span class="cov0" title="0">os.Exit(1)</span>
        } else<span class="cov0" title="0"> {
                // Файл существует, оставляем начальное состояние (welcomeScreen -&gt; passwordInputScreen)
                slog.Info("Файл KDBX найден, запуск стандартного TUI.", "path", m.kdbxPath)
                // Состояние по умолчанию welcomeScreen в initModel
        }</span>

        // Используем FullAltScreen для корректной работы списка
        <span class="cov0" title="0">p := tea.NewProgram(&amp;m, tea.WithAltScreen()) // Передаем указатель на модель
        if _, errRun := p.Run(); errRun != nil </span><span class="cov0" title="0">{
                slog.Error("Ошибка при запуске TUI", "error", errRun)
                // Разблокируем файл перед выходом
                if m.lockAcquired </span><span class="cov0" title="0">{
                        _ = m.fileLock.Unlock()
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        // Успешный выход ПОСЛЕ defer Unlock
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package tui

import (
        "errors"
        "fmt"
        "log/slog"
        "time"

        // Убедимся, что импорты на месте.
        tea "github.com/charmbracelet/bubbletea"
        "github.com/maynagashev/gophkeeper/client/internal/api"
        "github.com/maynagashev/gophkeeper/client/internal/kdbx"
        "github.com/tobischo/gokeepasslib/v3/wrappers"
)

// handleWindowSizeMsg обрабатывает изменение размера окна.
func handleWindowSizeMsg(m *model, msg tea.WindowSizeMsg) <span class="cov0" title="0">{
        // Обновляем размеры компонентов
        h, v := m.docStyle.GetFrameSize() // Используем стиль из модели
        listWidth := msg.Width - h
        // Высота для основного списка записей
        entryListHeight := msg.Height - v - helpStatusHeightOffset // Используем константу

        // Высота для меню синхронизации
        // Статус занимает 3 строки + 1 строка разделитель = 4
        const statusHeight = 4
        syncMenuHeight := msg.Height - v - statusHeight

        m.entryList.SetSize(listWidth, entryListHeight)
        m.passwordInput.Width = msg.Width - passwordInputOffset
        m.syncServerMenu.SetSize(listWidth, syncMenuHeight) // Используем новую высоту

        // TODO: Обновить размеры других полей ввода по необходимости
        m.serverURLInput.Width = listWidth - passwordInputOffset
        m.loginUsernameInput.Width = listWidth - passwordInputOffset
        m.loginPasswordInput.Width = listWidth - passwordInputOffset
        m.registerUsernameInput.Width = listWidth - passwordInputOffset
        m.registerPasswordInput.Width = listWidth - passwordInputOffset
}</span>

// handleDBMsg обрабатывает сообщения, связанные с базой данных или статусом.
func handleDBMsg(m *model, msg tea.Msg) (tea.Model, tea.Cmd, bool) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case dbOpenedMsg:<span class="cov8" title="1">
                newM, cmd := handleDBOpenedMsg(m, msg)
                return newM, cmd, true</span>
        case errMsg:<span class="cov0" title="0">
                newM := handleErrorMsg(m, msg)
                return newM, nil, true</span>
        case dbSavedMsg:<span class="cov0" title="0">
                newM, cmd := handleDBSavedMsg(m)
                return newM, cmd, true</span>
        case dbSaveErrorMsg:<span class="cov0" title="0">
                newM, cmd := handleDBSaveErrorMsg(m, msg)
                return newM, cmd, true</span>
        case clearStatusMsg:<span class="cov0" title="0">
                newM, cmd := handleClearStatusMsg(m)
                return newM, cmd, true</span>
        case SyncError:<span class="cov0" title="0">
                newM, cmd := handleSyncErrorMsg(m, msg)
                return newM, cmd, true</span>
        case syncStartedMsg:<span class="cov0" title="0">
                newM, cmd := handleSyncStartedMsg(m)
                return newM, cmd, true</span>
        case serverMetadataMsg:<span class="cov0" title="0">
                newM, cmd := handleServerMetadataMsg(m, msg)
                return newM, cmd, true</span>
        case localMetadataMsg:<span class="cov0" title="0">
                newM, cmd := handleLocalMetadataMsg(m, msg)
                return newM, cmd, true</span>
        case syncUploadSuccessMsg:<span class="cov0" title="0">
                newM, cmd := handleSyncUploadSuccessMsg(m)
                return newM, cmd, true</span>
        case syncDownloadSuccessMsg:<span class="cov0" title="0">
                newM, cmd := handleSyncDownloadSuccessMsg(m, msg)
                return newM, cmd, true</span>
        default:<span class="cov0" title="0">
                return m, nil, false</span> // Не обработали сообщение этого типа
        }
}

// --- Обработчики для handleDBMsg ---

func handleDBOpenedMsg(m *model, msg dbOpenedMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        return m.handleDBOpenedMsg(msg)
}</span>

func handleErrorMsg(m *model, msg errMsg) tea.Model <span class="cov8" title="1">{
        return m.handleErrorMsg(msg)
}</span>

func handleDBSavedMsg(m *model) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Добавляем tea.ClearScreen в Batch после установки статуса
        newM, statusCmd := m.setStatusMessage("Сохранено успешно!")
        return newM, tea.Batch(statusCmd, tea.ClearScreen)
}</span>

func handleDBSaveErrorMsg(m *model, msg dbSaveErrorMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        return m.setStatusMessage(fmt.Sprintf("Ошибка сохранения: %v", msg.err))
}</span>

func handleClearStatusMsg(m *model) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.savingStatus = ""
        m.statusTimer = nil // Обнуляем таймер (хотя он и так не используется для отмены)
        // Возвращаем команду для принудительной перерисовки
        return m, tea.ClearScreen
}</span>

func handleSyncErrorMsg(m *model, msg SyncError) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.isSyncing = false
        // Проверяем на ошибку авторизации
        if errors.Is(msg.err, api.ErrAuthorization) </span><span class="cov8" title="1">{
                m.state = loginRegisterChoiceScreen // Переходим на экран выбора входа/регистрации
                // Можно добавить очистку экрана, если нужно
                newM, statusCmd := m.setStatusMessage("Сессия истекла. Пожалуйста, войдите снова (L).")
                return newM, tea.Batch(statusCmd, tea.ClearScreen)
        }</span>
        // Иначе показываем общую ошибку синхронизации
        // Добавляем ClearScreen и здесь
        <span class="cov8" title="1">newM, statusCmd := m.setStatusMessage(fmt.Sprintf("Ошибка синхронизации: %v", msg.err))
        return newM, tea.Batch(statusCmd, tea.ClearScreen)</span>
}

func handleSyncStartedMsg(m *model) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        m.isSyncing = true
        m.receivedServerMeta = false
        m.receivedLocalMeta = false
        newM, statusCmd := m.setStatusMessage("Получение метаданных...")
        fetchCmds := tea.Batch(fetchServerMetadataCmd(m), fetchLocalMetadataCmd(m))
        return newM, tea.Batch(statusCmd, fetchCmds)
}</span>

func handleServerMetadataMsg(m *model, msg serverMetadataMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if !m.isSyncing </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov8" title="1">m.serverMeta = msg.metadata
        m.serverMetaFound = msg.found
        m.receivedServerMeta = true
        slog.Debug("Получено сообщение serverMetadataMsg", "found", msg.found)
        if m.receivedLocalMeta </span><span class="cov8" title="1">{
                newM, cmd := m.processMetadataResults()
                return newM, cmd
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func handleLocalMetadataMsg(m *model, msg localMetadataMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if !m.isSyncing </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov8" title="1">m.localMetaModTime = msg.modTime
        m.localMetaFound = msg.found
        m.receivedLocalMeta = true
        slog.Debug("Получено сообщение localMetadataMsg", "found", msg.found)
        if m.receivedServerMeta </span><span class="cov8" title="1">{
                newM, cmd := m.processMetadataResults()
                return newM, cmd
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func handleSyncUploadSuccessMsg(m *model) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // TODO: Обновить время последней синхронизации в m
        newM, statusCmd := m.setStatusMessage("Синхронизация завершена (загружено)")
        // Добавляем ClearScreen
        return newM, tea.Batch(statusCmd, tea.ClearScreen)
}</span>

func handleSyncDownloadSuccessMsg(m *model, msg syncDownloadSuccessMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        newM, statusCmd := m.setStatusMessage("Синхронизация завершена (скачано), перезагрузка...")
        if msg.reloadNeeded </span><span class="cov0" title="0">{
                openCmd := openKdbxCmd(m.kdbxPath, m.password)
                return newM, tea.Batch(statusCmd, openCmd)
        }</span>
        <span class="cov0" title="0">return newM, statusCmd</span>
}

// processMetadataResults обрабатывает ситуацию, когда получены и локальные, и серверные метаданные.
func (m *model) processMetadataResults() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        slog.Info("Получены метаданные сервера и локального файла. Запуск сравнения...")

        // Определяем время модификации контента с сервера
        // (Используем новое поле ContentModifiedAt)
        var serverModTime time.Time
        if m.serverMeta != nil &amp;&amp; m.serverMeta.ContentModifiedAt != nil </span><span class="cov8" title="1">{
                serverModTime = *m.serverMeta.ContentModifiedAt
        }</span>

        <span class="cov8" title="1">slog.Debug("Данные для сравнения",
                "serverFound", m.serverMetaFound,
                "serverMetaTime", serverModTime, // Теперь это ContentModifiedAt
                "localFound", m.localMetaFound,
                "localMetaTime", m.localMetaModTime, // Это local db.Root.LastModificationTime
        )

        // Сбрасываем флаги получения
        m.receivedServerMeta = false
        m.receivedLocalMeta = false
        m.isSyncing = false // Завершаем состояние синхронизации

        var cmd tea.Cmd
        var statusMsg string

        switch </span>{
        // Случай 1: Хранилища нет на сервере (404)
        case !m.serverMetaFound:<span class="cov0" title="0">
                if m.localMetaFound </span><span class="cov0" title="0">{
                        slog.Info("Хранилища нет на сервере, локальное есть. Загрузка на сервер.")
                        statusMsg = "Загрузка на сервер..."
                        cmd = uploadVaultCmd(m) // Команда загрузки
                }</span> else<span class="cov0" title="0"> {
                        slog.Info("Нет ни локального хранилища, ни на сервере. Нечего синхронизировать.")
                        statusMsg = "Нечего синхронизировать."
                        cmd = nil // Ничего не делаем
                }</span>
        // Случай 2: Хранилище есть на сервере
        case m.serverMetaFound:<span class="cov8" title="1">
                if !m.localMetaFound </span><span class="cov0" title="0">{
                        // Случай 3: Локального файла нет, но на сервере есть
                        slog.Info("Локального файла нет, но есть на сервере. Скачивание с сервера.")
                        statusMsg = "Скачивание с сервера..."
                        cmd = downloadVaultCmd(m) // Команда скачивания
                }</span> else<span class="cov8" title="1"> {
                        // Обе версии существуют, сравниваем время
                        // Переписываем if-else на switch для gocritic
                        switch </span>{
                        case m.localMetaModTime.After(serverModTime):<span class="cov8" title="1">
                                slog.Info("Локальная версия новее. Загрузка на сервер.")
                                statusMsg = "Загрузка на сервер..."
                                cmd = uploadVaultCmd(m)</span> // Команда загрузки
                        case serverModTime.After(m.localMetaModTime):<span class="cov0" title="0">
                                slog.Info("Серверная версия новее. Скачивание с сервера.")
                                statusMsg = "Скачивание с сервера..."
                                cmd = downloadVaultCmd(m)</span> // Команда скачивания
                        default:<span class="cov8" title="1"> // Времена равны
                                slog.Info("Версии идентичны. Синхронизация не требуется.")
                                statusMsg = "Уже синхронизировано."
                                cmd = nil</span> // Ничего не делаем
                        }
                }
        }

        // Устанавливаем статус и возвращаем команду
        <span class="cov8" title="1">newM, statusCmd := m.setStatusMessage(statusMsg)
        // Объединяем команду установки статуса с командой загрузки/скачивания (если она есть)
        finalCmd := tea.Batch(statusCmd, cmd)

        return newM, finalCmd</span>
}

// handleVersionMsg обрабатывает сообщения, связанные с версиями.
func handleVersionMsg(m *model, msg tea.Msg) (tea.Model, tea.Cmd, bool) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case versionsLoadedMsg:<span class="cov0" title="0">
                newM, cmd := handleVersionsLoadedMsg(m, msg)
                return newM, cmd, true</span>
        case versionsLoadErrorMsg:<span class="cov0" title="0">
                newM, cmd := handleVersionsLoadErrorMsg(m, msg)
                return newM, cmd, true</span>
        case rollbackSuccessMsg:<span class="cov0" title="0">
                newM, cmd := handleRollbackSuccessMsg(m, msg)
                return newM, cmd, true</span>
        case rollbackErrorMsg:<span class="cov0" title="0">
                newM, cmd := handleRollbackErrorMsg(m, msg)
                return newM, cmd, true</span>
        default:<span class="cov0" title="0">
                return m, nil, false</span> // Не обработали сообщение этого типа
        }
}

// handleAPIMsg обрабатывает сообщения от API клиента.
func handleAPIMsg(m *model, msg tea.Msg) (tea.Model, tea.Cmd, bool) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case loginSuccessMsg:<span class="cov8" title="1">
                m.authToken = msg.Token
                m.loginStatus = fmt.Sprintf("Вход выполнен как %s", m.loginUsernameInput.Value())
                m.err = nil
                m.loginUsernameInput.SetValue("")
                m.loginPasswordInput.SetValue("")

                // Устанавливаем токен в существующем API клиенте
                if m.apiClient != nil </span><span class="cov8" title="1">{
                        m.apiClient.SetAuthToken(m.authToken)
                        slog.Debug("Установлен токен в API клиенте после успешного входа")
                }</span> else<span class="cov0" title="0"> {
                        slog.Error("API клиент nil при попытке установить токен после входа")
                }</span>

                // Сохраняем Auth данные в KDBX (в памяти)
                <span class="cov8" title="1">if m.db != nil </span><span class="cov8" title="1">{
                        errSave := kdbx.SaveAuthData(m.db, m.serverURL, m.authToken)
                        if errSave != nil </span><span class="cov0" title="0">{
                                slog.Error("Ошибка сохранения Auth данных в KDBX (в памяти)", "error", errSave)
                                m.err = fmt.Errorf("ошибка сохранения данных сессии: %w", errSave)
                                m.state = loginScreen // Остаемся на экране входа для показа ошибки
                                newM, statusCmd := m.setStatusMessage("Ошибка сохранения сессии")
                                return newM, tea.Batch(statusCmd, tea.ClearScreen), true // Возвращаемся при ошибке
                        }</span>
                        // Если ошибки не было
                        <span class="cov8" title="1">slog.Info("Auth данные успешно обновлены в KDBX (в памяти)")
                        m.state = entryListScreen</span> // Переходим к списку записей
                } else<span class="cov0" title="0"> {
                        slog.Error("Попытка сохранить Auth данные в KDBX, но m.db is nil")
                        m.state = entryListScreen // Переходим к списку, но без сохранения данных сессии
                }</span>

                // Возвращаем команды только после успешного сохранения (или если db был nil)
                <span class="cov8" title="1">newM, statusCmd := m.setStatusMessage("Вход выполнен успешно!")
                return newM, tea.Batch(statusCmd, tea.ClearScreen), true</span>

        case LoginError:<span class="cov8" title="1">
                m.err = msg.err
                newM, statusCmd := m.setStatusMessage("Ошибка входа")
                // Добавляем очистку экрана, чтобы перерисовать с ошибкой чисто
                return newM, tea.Batch(statusCmd, tea.ClearScreen), true</span>

        // --- Обработка регистрации --- //
        case registerSuccessMsg:<span class="cov8" title="1">
                m.err = nil
                m.registerUsernameInput.SetValue("")
                m.registerPasswordInput.SetValue("")
                m.state = loginScreen
                m.loginUsernameInput.Focus()
                m.loginRegisterFocusedField = 0
                newM, statusCmd := m.setStatusMessage("Регистрация успешна! Теперь войдите.")
                // Добавляем команду очистки экрана
                return newM, tea.Batch(statusCmd, tea.ClearScreen), true</span>

        case RegisterError:<span class="cov8" title="1">
                m.err = msg.err
                newM, statusCmd := m.setStatusMessage("Ошибка регистрации")
                // Добавляем очистку экрана, чтобы перерисовать с ошибкой чисто
                return newM, tea.Batch(statusCmd, tea.ClearScreen), true</span>

        default:<span class="cov8" title="1">
                return m, nil, false</span>
        }
}

// canSave checks if the application is in a state where saving is allowed.
func (m *model) canSave() bool <span class="cov8" title="1">{
        return !m.readOnlyMode &amp;&amp; m.db != nil &amp;&amp; (m.state == entryListScreen || m.state == entryDetailScreen)
}</span>

// updateDBFromList updates the in-memory database (m.db) with data from the TUI list (m.entryList).
func (m *model) updateDBFromList() int <span class="cov8" title="1">{
        slog.Info("Начало обновления m.db перед сохранением")
        items := m.entryList.Items()
        updatedCount := 0
        for _, item := range items </span><span class="cov8" title="1">{
                listItem, ok := item.(entryItem)
                if !ok </span><span class="cov0" title="0">{
                        continue</span> // Skip if not an entryItem
                }
                // Находим соответствующую запись в m.db по UUID
                <span class="cov8" title="1">dbEntryPtr := findEntryInDB(m.db, listItem.entry.UUID)
                if dbEntryPtr != nil </span><span class="cov8" title="1">{
                        // Обновляем найденную запись данными из элемента списка
                        // Создаем копию перед присваиванием, чтобы не менять listItem
                        entryToSave := deepCopyEntry(listItem.entry)
                        *dbEntryPtr = entryToSave
                        updatedCount++
                }</span> else<span class="cov8" title="1"> {
                        slog.Warn("Запись из списка не найдена в m.db", "uuid", listItem.entry.UUID)
                }</span>
        }
        <span class="cov8" title="1">slog.Info("Обновление m.db завершено", "updated_count", updatedCount)
        return updatedCount</span>
}

// updateRootModTime updates the LastModificationTime of the root group.
func (m *model) updateRootModTime() <span class="cov8" title="1">{
        if m.db == nil || m.db.Content == nil || m.db.Content.Root == nil </span><span class="cov8" title="1">{
                slog.Warn("Не удалось обновить LastModificationTime: db, Content или Root is nil")
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()
        modTimeWrapper := wrappers.TimeWrapper{Time: now}

        // Обновляем время модификации первой (корневой) группы
        if len(m.db.Content.Root.Groups) &gt; 0 </span><span class="cov8" title="1">{
                rootGroup := &amp;m.db.Content.Root.Groups[0]
                rootGroup.Times.LastModificationTime = &amp;modTimeWrapper // Присваиваем указатель
                slog.Debug("Обновлено LastModificationTime корневой группы перед сохранением", "newTime", now)
        }</span> else<span class="cov8" title="1"> {
                slog.Warn("Не удалось обновить LastModificationTime: нет корневой группы")
        }</span>
}

// handleSaveKeyPress handles the logic for the Ctrl+S key press.
func (m *model) handleSaveKeyPress() (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        if !m.canSave() </span><span class="cov8" title="1">{
                return m, nil // Not in a state to save, or read-only
        }</span>

        <span class="cov8" title="1">m.savingStatus = "Подготовка к сохранению..."

        // Update m.db from the list UI
        m.updateDBFromList()

        // Update the root modification time
        m.updateRootModTime()

        m.savingStatus = "Сохранение..."
        slog.Info("Запуск сохранения KDBX", "path", m.kdbxPath)
        // Use the stored password
        return m, saveKdbxCmd(m.db, m.kdbxPath, m.password)</span>
}

// handleGlobalKeys обрабатывает глобальные сочетания клавиш.
func handleGlobalKeys(m *model, msg tea.KeyMsg) (tea.Model, tea.Cmd, bool) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "ctrl+c":<span class="cov8" title="1">
                return m, tea.Quit, true</span>
        case "ctrl+s":<span class="cov8" title="1">
                // Delegate saving logic to a separate function
                updatedModel, cmd := m.handleSaveKeyPress()
                // Return true only if saving was actually attempted (canSave was true)
                return updatedModel, cmd, m.canSave()</span>
        default:<span class="cov8" title="1">
                // Клавиша не является глобальной
                return m, nil, false</span>
        }
}

// Update обрабатывает входящие сообщения.
//
//nolint:funlen // TODO: Рефакторить роутинг и длину функции (убрали gocyclo)
func (m *model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd         // Собираем команды для батчинга
        var cmd tea.Cmd            // Команда от обработчика
        var handled bool           // Флаг: сообщение было обработано глобальным хендлером
        var updatedModel tea.Model // Модель по умолчанию - текущая (убираем `= m`)

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                // Обработка изменения размера окна
                handleWindowSizeMsg(m, msg)
                return m, nil</span> // Возвращаем nil команду здесь, так как команда не нужна

        case tea.KeyMsg:<span class="cov8" title="1">
                // Обработка глобальных клавиш
                updatedModel, cmd, handled = handleGlobalKeys(m, msg)
                if handled </span><span class="cov8" title="1">{
                        return updatedModel, cmd
                }</span>
                // Если не глобальная клавиша, передаем дальше для обработки по состоянию

        default:<span class="cov8" title="1">
                // Сначала пытаемся обработать сообщения API
                updatedModel, cmd, handled = handleAPIMsg(m, msg)
                if handled </span><span class="cov0" title="0">{
                        return updatedModel, cmd
                }</span>

                // Затем пытаемся обработать сообщения БД/статуса
                <span class="cov8" title="1">updatedModel, cmd, handled = handleDBMsg(m, msg)
                if handled </span><span class="cov8" title="1">{
                        return updatedModel, cmd
                }</span>

                // Затем пытаемся обработать сообщения версий
                <span class="cov0" title="0">updatedModel, cmd, handled = handleVersionMsg(m, msg)
                if handled </span><span class="cov0" title="0">{
                        return updatedModel, cmd
                }</span>
        }

        // == Обработка сообщения в зависимости от текущего состояния ==
        // (Вызывается, только если сообщение не было обработано глобально)
        <span class="cov8" title="1">var stateCmd tea.Cmd
        switch m.state </span>{
        case welcomeScreen:<span class="cov8" title="1">
                updatedModel, stateCmd = m.updateWelcomeScreen(msg)</span>
        case passwordInputScreen:<span class="cov8" title="1">
                updatedModel, stateCmd = m.updatePasswordInputScreen(msg)</span>
        case newKdbxPasswordScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateNewKdbxPasswordScreen(msg)</span>
        case entryListScreen:<span class="cov8" title="1">
                updatedModel, stateCmd = m.updateEntryListScreen(msg)</span>
        case entryDetailScreen:<span class="cov8" title="1">
                updatedModel, stateCmd = m.updateEntryDetailScreen(msg)</span>
        case entryEditScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateEntryEditScreen(msg)</span>
        case entryAddScreen:<span class="cov8" title="1">
                updatedModel, stateCmd = m.updateEntryAddScreen(msg)</span>
        case attachmentListDeleteScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateAttachmentListDeleteScreen(msg)</span>
        case attachmentPathInputScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateAttachmentPathInputScreen(msg)</span>
        case syncServerScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateSyncServerScreen(msg)</span>
        case serverURLInputScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateServerURLInputScreen(msg)</span>
        case loginRegisterChoiceScreen:<span class="cov8" title="1">
                updatedModel, stateCmd = m.updateLoginRegisterChoiceScreen(msg)</span>
        case loginScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateLoginScreen(msg)</span>
        case registerScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateRegisterScreen(msg)</span>
        case versionListScreen:<span class="cov0" title="0">
                updatedModel, stateCmd = m.updateVersionListScreen(msg)</span>
        default:<span class="cov0" title="0">
                // Неизвестное состояние - ничего не делаем, updatedModel остается nil?
                // Это нужно обработать: если updatedModel не был присвоен,
                // нужно вернуть исходную модель m.
                updatedModel = m</span> // Присваиваем m, если ни один case не сработал
                // stateCmd остается nil
        }
        <span class="cov8" title="1">cmds = append(cmds, stateCmd) // Добавляем команду от обработчика состояния

        // Кастуем тип обратно к *model перед возвратом
        finalModel, ok := updatedModel.(*model)
        if !ok </span><span class="cov0" title="0">{
                // Это не должно произойти, если все update... функции возвращают *model
                // Или если updatedModel не был присвоен в default
                slog.Error("Ошибка каста модели в *model или updatedModel не был присвоен")
                return m, tea.Quit // Выход в случае серьезной ошибки
        }</span>

        <span class="cov8" title="1">return finalModel, tea.Batch(cmds...)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package tui

import (
        "github.com/tobischo/gokeepasslib/v3"
)

// DeepCopyEntry создает глубокую копию записи.
func DeepCopyEntry(original gokeepasslib.Entry) gokeepasslib.Entry <span class="cov8" title="1">{
        newEntry := gokeepasslib.NewEntry()

        // Копируем UUID
        copy(newEntry.UUID[:], original.UUID[:])

        // Копируем основные поля
        newEntry.Times = original.Times
        newEntry.Tags = original.Tags
        newEntry.CustomData = original.CustomData

        // Глубокое копирование Values
        if original.Values != nil </span><span class="cov8" title="1">{
                newEntry.Values = make([]gokeepasslib.ValueData, len(original.Values))
                for i, val := range original.Values </span><span class="cov8" title="1">{
                        newValue := gokeepasslib.ValueData{
                                Key:   val.Key,
                                Value: gokeepasslib.V{Content: val.Value.Content, Protected: val.Value.Protected},
                        }
                        newEntry.Values[i] = newValue
                }</span>
        }

        // Копируем срез ссылок на бинарные данные (BinaryReference)
        // Сами структуры BinaryReference содержат простые типы (Name, Value.ID),
        // поэтому достаточно поверхностного копирования среза.
        <span class="cov8" title="1">if original.Binaries != nil </span><span class="cov0" title="0">{
                newEntry.Binaries = make([]gokeepasslib.BinaryReference, len(original.Binaries))
                copy(newEntry.Binaries, original.Binaries)
        }</span>

        // TODO: Добавить копирование History, если оно будет редактироваться

        <span class="cov8" title="1">return newEntry</span>
}

// deepCopyEntry - алиас для совместимости со старым кодом.
// Использует публичную функцию DeepCopyEntry.
func deepCopyEntry(original gokeepasslib.Entry) gokeepasslib.Entry <span class="cov8" title="1">{
        return DeepCopyEntry(original)
}</span>

// FindEntryInDB ищет запись по UUID в базе данных.
func FindEntryInDB(db *gokeepasslib.Database, uuid gokeepasslib.UUID) *gokeepasslib.Entry <span class="cov8" title="1">{
        if db == nil || db.Content == nil || db.Content.Root == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return FindEntryInGroups(db.Content.Root.Groups, uuid)</span>
}

// findEntryInDB - алиас для совместимости со старым кодом.
// Использует публичную функцию FindEntryInDB.
func findEntryInDB(db *gokeepasslib.Database, uuid gokeepasslib.UUID) *gokeepasslib.Entry <span class="cov8" title="1">{
        return FindEntryInDB(db, uuid)
}</span>

// FindEntryInGroups рекурсивно ищет запись по UUID.
func FindEntryInGroups(groups []gokeepasslib.Group, uuid gokeepasslib.UUID) *gokeepasslib.Entry <span class="cov8" title="1">{
        for i := range groups </span><span class="cov8" title="1">{
                group := &amp;groups[i]
                // Поиск в текущей группе
                for j := range group.Entries </span><span class="cov8" title="1">{
                        entry := &amp;group.Entries[j]
                        if entry.UUID == uuid </span><span class="cov8" title="1">{
                                return entry
                        }</span>
                }
                // Поиск в подгруппах
                <span class="cov8" title="1">if entry := FindEntryInGroups(group.Groups, uuid); entry != nil </span><span class="cov8" title="1">{
                        return entry
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
