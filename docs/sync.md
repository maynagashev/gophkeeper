# Логика Синхронизации Клиента GophKeeper

Этот документ описывает алгоритм, используемый TUI-клиентом для синхронизации локального хранилища KDBX с сервером GophKeeper.

## Основной Принцип

Используется стратегия **Last Write Wins (LWW)**, основанная на времени последней модификации файла на сервере и локально.

## Триггер Синхронизации

Синхронизация инициируется пользователем через пункт меню "Синхронизировать сейчас" на экране "Синхронизация и Сервер".

## Предусловия

Перед началом синхронизации клиент проверяет следующие условия:

1. **Настроен URL Сервера:** `model.serverURL` должен быть не пустым.
2. **Пользователь Аутентифицирован:** `model.authToken` должен быть не пустым и валидным.
3. **API Клиент Инициализирован:** `model.apiClient` должен существовать.
4. **Локальная База Загружена:** `model.db` должен быть загружен (файл KDBX успешно открыт).

Если хотя бы одно из условий не выполнено, процесс прерывается, и пользователю выводится соответствующее сообщение об ошибке (например, "Необходимо войти" или "URL сервера не настроен").

## Шаги Синхронизации

1. **Отображение статуса:** Клиент показывает пользователю сообщение "Синхронизация...".
2. **Получение Метаданных с Сервера:**
    * Клиент выполняет `GET /api/vault` для получения метаданных текущей версии хранилища на сервере (`version_id`, `last_modified`, `hash`).
    * **Обработка ошибок:**
        * `401 Unauthorized`: Ошибка авторизации (токен невалиден/истек). Синхронизация прерывается, предлагается войти заново.
        * `404 Not Found`: Хранилища на сервере не существует. Это обрабатывается в следующем шаге.
        * Другие ошибки (сеть, 5xx): Синхронизация прерывается с сообщением об ошибке.
3. **Получение Локальных Метаданных:**
    * Клиент получает время последней модификации (`LastModified`) локального файла `kdbxPath` с помощью `os.Stat`.
    * (Опционально в будущем): Вычисляется хеш локального файла.
4. **Логика Сравнения и Выбор Действия (LWW):**
    * **Случай 1: Хранилища нет на сервере (`404` на шаге 2):**
        * Если локальный файл `kdbxPath` существует (`m.db != nil`), выполняется **Загрузка (Upload)** локальной версии на сервер.
        * Если локального файла нет, выводится сообщение "Нечего синхронизировать".
    * **Случай 2: Хранилище есть на сервере:**
        * Сравниваются `serverMeta.LastModified` и `localFileModTime`.
        * Если `localFileModTime > serverMeta.LastModified`: Локальная версия новее -> Выполняется **Загрузка (Upload)**.
        * Если `serverMeta.LastModified > localFileModTime`: Серверная версия новее -> Выполняется **Скачивание (Download)**.
        * Если `serverMeta.LastModified == localFileModTime`: Считается, что версии идентичны. Выводится сообщение "Уже синхронизировано".
    * **Случай 3: Локального файла нет, но на сервере есть:** Выполняется **Скачивание (Download)**.
5. **Выполнение Загрузки (Upload):**
    * **Предварительное Сохранение:** Любые несохраненные изменения в TUI применяются к `model.db` (в памяти).
    * Открывается локальный файл `kdbxPath` для чтения.
    * Получается размер файла.
    * Выполняется `POST /api/vault/upload` с содержимым файла в теле запроса и заголовками `Authorization`, `Content-Type: application/octet-stream`, `Content-Length`.
    * **Обработка ошибок:** Сеть, `401`, `5xx`.
    * При успехе: Обновляется статус `model.lastSyncStatus`, выводится сообщение "Синхронизация завершена".
6. **Выполнение Скачивания (Download):**
    * Выполняется `GET /api/vault/download` с заголовком `Authorization`.
    * **Обработка ошибок:** Сеть, `401`, `404`, `5xx`.
    * (Опционально, но рекомендуется): Создается резервная копия текущего локального файла `kdbxPath`.
    * Содержимое ответа сервера (тело `io.ReadCloser`) полностью читается и записывается в локальный файл `kdbxPath`, **перезаписывая** его.
    * **Перезагрузка Базы:** Клиент заново открывает обновленный `kdbxPath`, используя сохраненный мастер-пароль, и загружает его в `model.db`. Список записей в TUI (`model.entryList`) обновляется на основе нового `model.db`.
    * При успехе: Обновляется статус `model.lastSyncStatus`, выводится сообщение "Синхронизация завершена".

## Завершение

После успешной загрузки/скачивания или определения, что синхронизация не требуется, статус "Синхронизация..." убирается, и пользователь видит финальное сообщение ("Синхронизация завершена", "Уже синхронизировано" или сообщение об ошибке). 