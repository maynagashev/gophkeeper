# Логика Синхронизации Клиента GophKeeper

Этот документ описывает алгоритм, используемый TUI-клиентом для синхронизации локального хранилища KDBX с сервером GophKeeper.

## Основной Принцип

Используется стратегия **Last Write Wins (LWW)**, основанная на **внутреннем времени последней модификации контента** файла KDBX на сервере и локально. Это время хранится в метаданных KDBX (`Root/LastModificationTime`) и отражает последнее изменение пользовательских данных (записей, групп), а не просто время загрузки файла на сервер.

## Триггер Синхронизации

Синхронизация инициируется пользователем через пункт меню "Синхронизировать сейчас" на экране "Синхронизация и Сервер".

## Предусловия

Перед началом синхронизации клиент проверяет следующие условия:

1. **Настроен URL Сервера:** `model.serverURL` должен быть не пустым.
2. **Пользователь Аутентифицирован:** `model.authToken` должен быть не пустым и валидным.
3. **API Клиент Инициализирован:** `model.apiClient` должен существовать.
4. **Локальная База Загружена:** `model.db` должен быть загружен (файл KDBX успешно открыт).

Если хотя бы одно из условий не выполнено, процесс прерывается, и пользователю выводится соответствующее сообщение об ошибке (например, "Необходимо войти" или "URL сервера не настроен").

## Шаги Синхронизации

1. **Отображение статуса:** Клиент показывает пользователю сообщение "Синхронизация...".
2. **Получение Метаданных с Сервера:**
    * Клиент выполняет `GET /api/vault` для получения метаданных текущей версии хранилища на сервере. Ключевые поля:
        * `exists`: Существует ли хранилище на сервере.
        * `version_id`: ID текущей версии.
        * `content_modified_at`: Время последнего изменения *контента* KDBX на сервере (из `Root/LastModificationTime` на момент загрузки).
        * `hash` (опционально): Хеш файла на сервере.
    * **Обработка ошибок:**
        * `401 Unauthorized`: Ошибка авторизации (токен невалиден/истек). Синхронизация прерывается, предлагается войти заново.
        * `404 Not Found`: Хранилища на сервере не существует. Это обрабатывается в следующем шаге.
        * Другие ошибки (сеть, 5xx): Синхронизация прерывается с сообщением об ошибке.
3. **Получение Локальных Метаданных:**
    * Клиент получает время последней модификации контента (`contentModTime`) из загруженной базы данных: `localContentModTime = m.db.Root.LastModificationTime`.
    * (Опционально в будущем): Вычисляется хеш локального файла.
4. **Логика Сравнения и Выбор Действия (LWW):**
    * **Случай 1: Хранилища нет на сервере (`404` или `exists: false` на шаге 2):**
        * Если локальный файл `kdbxPath` существует (`m.db != nil`), выполняется **Загрузка (Upload)** локальной версии на сервер.
        * Если локального файла нет, выводится сообщение "Нечего синхронизировать".
    * **Случай 2: Хранилище есть на сервере:**
        * Сравниваются `serverMeta.ContentModifiedAt` и `localContentModTime`.
        * Если `localContentModTime > serverMeta.ContentModifiedAt`: Локальная версия новее -> Выполняется **Загрузка (Upload)**.
        * Если `serverMeta.ContentModifiedAt > localContentModTime`: Серверная версия новее -> Выполняется **Скачивание (Download)**.
        * Если `serverMeta.ContentModifiedAt == localContentModTime`: Считается, что версии идентичны по контенту. Выводится сообщение "Уже синхронизировано". (Примечание: Даже если локально были сохранены только метаданные авторизации, `localContentModTime` обновится, но если контент на сервере не менялся, времена будут равны после успешной загрузки).
    * **Случай 3: Локального файла нет, но на сервере есть:** Выполняется **Скачивание (Download)**.
5. **Выполнение Загрузки (Upload):**
    * **Предварительное Сохранение:** Любые несохраненные изменения в TUI применяются к `model.db` (в памяти). Важно: Это включает и возможное сохранение метаданных авторизации, которое обновит `m.db.Root.LastModificationTime`.
    * Открывается локальный файл `kdbxPath` для чтения.
    * Получается размер файла.
    * Выполняется `POST /api/vault/upload` с содержимым файла в теле запроса и заголовками `Authorization`, `Content-Type: application/octet-stream`, `Content-Length`.
    * **Обработка ошибок:** Сеть, `401`, `5xx`.
    * При успехе: Обновляется статус `model.lastSyncStatus`, выводится сообщение "Синхронизация завершена".
    * **Новое поведение сервера:** Сервер теперь сравнивает переданное время модификации (`T_c`) и чек-сумму (`C_c`) с текущей версией на сервере (`T_s`, `C_s`):
      * Если `T_c > T_s`: Создается новая версия, ответ **HTTP 200 OK**.
      * Если `T_c < T_s` ИЛИ (`T_c == T_s` и `C_c != C_s`): Новая версия не создается (конфликт), ответ **HTTP 409 Conflict**. Клиенту следует предложить пользователю скачать актуальную версию.
      * Если `T_c == T_s` и `C_c == C_s`: Новая версия не создается (идентичная версия), ответ **HTTP 200 OK**. Клиент может считать синхронизацию успешной.
6. **Выполнение Скачивания (Download):**
    * Выполняется `GET /api/vault/download` с заголовком `Authorization`.
    * **Обработка ошибок:** Сеть, `401`, `404`, `5xx`.
    * (Опционально, но рекомендуется): Создается резервная копия текущего локального файла `kdbxPath`.
    * Содержимое ответа сервера (тело `io.ReadCloser`) полностью читается и записывается в локальный файл `kdbxPath`, **перезаписывая** его.
    * **Перезагрузка Базы:** Клиент заново открывает обновленный `kdbxPath`, используя сохраненный мастер-пароль, и загружает его в `model.db`. Локальное `m.db.Root.LastModificationTime` обновится до значения из скачанного файла. Список записей в TUI (`model.entryList`) обновляется на основе нового `model.db`.
    * При успехе: Обновляется статус `model.lastSyncStatus`, выводится сообщение "Синхронизация завершена".

## Завершение

После успешной загрузки/скачивания или определения, что синхронизация не требуется, статус "Синхронизация..." убирается, и пользователь видит финальное сообщение ("Синхронизация завершена", "Уже синхронизировано" или сообщение об ошибке). 

## Обработка Метаданных Авторизации

Когда пользователь входит в систему или меняет URL сервера, эти данные (токен, URL) сохраняются в `CustomData` внутри KDBX файла. Это действие также обновляет `m.db.Root.LastModificationTime` локально.

Как это влияет на синхронизацию:
- Если после сохранения метаданных пользователь инициирует синхронизацию, локальное `localContentModTime` будет новее, чем `serverMeta.ContentModifiedAt` (если на сервере не было изменений контента).
- Это приведет к **Загрузке (Upload)** файла на сервер.
- Сервер получит файл с актуальными метаданными авторизации и сохранит его как новую версию, записав актуальное `content_modified_at` (которое теперь будет совпадать с локальным).
- Это ожидаемое поведение для стратегии LWW, гарантирующее, что файл с последними (даже если только метаданными) изменениями окажется на сервере. 