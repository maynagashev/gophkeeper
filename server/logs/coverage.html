
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maynagashev/gophkeeper/server/cmd/server/flags.go (100.0%)</option>
				
				<option value="file1">github.com/maynagashev/gophkeeper/server/cmd/server/main.go (61.8%)</option>
				
				<option value="file2">github.com/maynagashev/gophkeeper/server/internal/handlers/auth.go (95.7%)</option>
				
				<option value="file3">github.com/maynagashev/gophkeeper/server/internal/handlers/vault_handler.go (92.2%)</option>
				
				<option value="file4">github.com/maynagashev/gophkeeper/server/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file5">github.com/maynagashev/gophkeeper/server/internal/repository/db.go (0.0%)</option>
				
				<option value="file6">github.com/maynagashev/gophkeeper/server/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file7">github.com/maynagashev/gophkeeper/server/internal/repository/vault_repository.go (0.0%)</option>
				
				<option value="file8">github.com/maynagashev/gophkeeper/server/internal/repository/vault_version_repository.go (0.0%)</option>
				
				<option value="file9">github.com/maynagashev/gophkeeper/server/internal/services/auth_service.go (0.0%)</option>
				
				<option value="file10">github.com/maynagashev/gophkeeper/server/internal/services/vault_service.go (52.2%)</option>
				
				<option value="file11">github.com/maynagashev/gophkeeper/server/internal/storage/minio_client.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "os"
)

const (
        // Порт по умолчанию для HTTPS (непривилегированный).
        defaultServerPort = "8443"

        // Переменные окружения.
        envServerPort  = "SERVER_PORT"
        envTLSCertFile = "TLS_CERT_FILE"
        envTLSKeyFile  = "TLS_KEY_FILE"
        envDatabaseDSN = "DATABASE_DSN"
)

// config хранит конфигурацию сервера.
type config struct {
        Port        string
        CertFile    string
        KeyFile     string
        DatabaseDSN string
}

// parseFlags разбирает флаги и переменные окружения, возвращает config или ошибку.
func parseFlags() (*config, error) <span class="cov8" title="1">{
        cfg := &amp;config{}

        // Определяем флаги
        flag.StringVar(&amp;cfg.Port, "port", "",
                fmt.Sprintf("Порт для запуска HTTPS-сервера (env: %s, default: %s)", envServerPort, defaultServerPort))
        flag.StringVar(&amp;cfg.CertFile, "cert-file", "",
                fmt.Sprintf("Путь к файлу TLS-сертификата (env: %s)", envTLSCertFile))
        flag.StringVar(&amp;cfg.KeyFile, "key-file", "",
                fmt.Sprintf("Путь к файлу TLS-ключа (env: %s)", envTLSKeyFile))
        flag.StringVar(&amp;cfg.DatabaseDSN, "database-dsn", "",
                fmt.Sprintf("Строка подключения к базе данных (env: %s)", envDatabaseDSN))

        // Парсим флаги
        flag.Parse()

        // Применяем переменные окружения, если флаги не заданы
        if cfg.Port == "" </span><span class="cov8" title="1">{
                if value, ok := os.LookupEnv(envServerPort); ok </span><span class="cov8" title="1">{
                        cfg.Port = value
                }</span> else<span class="cov8" title="1"> {
                        cfg.Port = defaultServerPort
                }</span>
        }
        <span class="cov8" title="1">if cfg.CertFile == "" </span><span class="cov8" title="1">{
                if value, ok := os.LookupEnv(envTLSCertFile); ok </span><span class="cov8" title="1">{
                        cfg.CertFile = value
                }</span>
        }
        <span class="cov8" title="1">if cfg.KeyFile == "" </span><span class="cov8" title="1">{
                if value, ok := os.LookupEnv(envTLSKeyFile); ok </span><span class="cov8" title="1">{
                        cfg.KeyFile = value
                }</span>
        }
        <span class="cov8" title="1">if cfg.DatabaseDSN == "" </span><span class="cov8" title="1">{
                if value, ok := os.LookupEnv(envDatabaseDSN); ok </span><span class="cov8" title="1">{
                        cfg.DatabaseDSN = value
                }</span>
        }

        // Проверяем обязательные параметры
        <span class="cov8" title="1">if cfg.CertFile == "" </span><span class="cov8" title="1">{
                return nil, errors.New("не указан путь к файлу сертификата (--cert-file или " + envTLSCertFile + ")")
        }</span>
        <span class="cov8" title="1">if cfg.KeyFile == "" </span><span class="cov8" title="1">{
                return nil, errors.New("не указан путь к файлу ключа (--key-file или " + envTLSKeyFile + ")")
        }</span>
        <span class="cov8" title="1">if cfg.DatabaseDSN == "" </span><span class="cov8" title="1">{
                return nil, errors.New("не указана строка подключения к БД (--database-dsn или " + envDatabaseDSN + ")")
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/jmoiron/sqlx" // Добавляем импорт sqlx
        _ "github.com/lib/pq"     // Драйвер PostgreSQL
        "github.com/maynagashev/gophkeeper/server/internal/handlers"
        appmiddleware "github.com/maynagashev/gophkeeper/server/internal/middleware"
        "github.com/maynagashev/gophkeeper/server/internal/repository"
        "github.com/maynagashev/gophkeeper/server/internal/services"
        "github.com/maynagashev/gophkeeper/server/internal/storage" // Добавляем импорт storage
)

const (
        defaultReadTimeout  = 10 * time.Second
        defaultWriteTimeout = 10 * time.Second
        defaultIdleTimeout  = 30 * time.Second

        // Переменные окружения для MinIO (значения по умолчанию из docker-compose).
        envMinioEndpoint     = "MINIO_ENDPOINT"
        envMinioUser         = "MINIO_USER"
        envMinioPassword     = "MINIO_PASSWORD"
        envMinioBucket       = "MINIO_BUCKET"
        defaultMinioEndpoint = "localhost:9000"
        defaultMinioUser     = "minioadmin"
        defaultMinioPassword = "minioadmin"
        defaultMinioBucket   = "gophkeeper-vaults"
        minioUseSSL          = false // Для локальной разработки
)

// Переменная для функции создания соединения с БД, для возможности мокирования в тестах.
var newPostgresDB = repository.NewPostgresDB //nolint:gochecknoglobals // Используется для мокирования в тестах

// Структура для хранения инициализированных зависимостей.
type dependencies struct {
        db           *sqlx.DB            // Используем тип *sqlx.DB
        fileStorage  storage.FileStorage // Используем интерфейс
        authHandler  *handlers.AuthHandler
        vaultHandler *handlers.VaultHandler
}

// Функция для запуска HTTP сервера (для удобства мокирования в тестах).
var startHTTPServer = //nolint:gochecknoglobals // Используется для мокирования в тестах
func(cfg *config, handler http.Handler) error <span class="cov0" title="0">{
        server := &amp;http.Server{
                Addr:         fmt.Sprintf(":%s", cfg.Port),
                Handler:      handler,
                ReadTimeout:  defaultReadTimeout,
                WriteTimeout: defaultWriteTimeout,
                IdleTimeout:  defaultIdleTimeout,
        }

        log.Printf("Запуск HTTPS-сервера на порту %s...", cfg.Port)
        log.Printf("Используется сертификат: %s", cfg.CertFile)
        log.Printf("Используется ключ: %s", cfg.KeyFile)

        // Запускаем сервер с TLS
        if err := server.ListenAndServeTLS(cfg.CertFile, cfg.KeyFile); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка запуска HTTPS-сервера: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// main - точка входа. Вызывает run и обрабатывает ошибку.
func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Ошибка выполнения сервера: %v", err) // Используем Printf
                os.Exit(1)                                       // Выход с кодом ошибки
        }</span>
}

// run содержит основную логику запуска сервера и возвращает ошибку.
func run() error <span class="cov0" title="0">{
        log.Println("Запуск сервера GophKeeper...")

        // Парсинг флагов командной строки
        cfg, err := parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                // Используем log.Fatalf, так как ошибка фатальна для запуска сервера.
                // В реальном тесте это приведет к завершению, нужна стратегия обхода.
                // Пока оставляем так, но тест должен будет мокировать parseFlags.
                log.Fatalf("Ошибка конфигурации сервера: %v", err)
        }</span>

        // Инициализация зависимостей
        <span class="cov0" title="0">deps, err := setupDependencies(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка инициализации зависимостей: %w", err)
        }</span>
        // Отложенное закрытие соединения с БД
        // Это гарантированно выполнится при выходе из run()
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if deps.db != nil </span><span class="cov0" title="0">{
                        if closeErr := deps.db.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                log.Printf("Ошибка закрытия соединения с БД: %v", closeErr)
                        }</span>
                }
        }()

        // Настройка роутера
        <span class="cov0" title="0">r := setupRouter(deps.authHandler, deps.vaultHandler)

        // --- Запуск сервера --- //
        // Используем переменную startHTTPServer вместо прямого кода запуска
        if err = startHTTPServer(cfg, r); err != nil </span><span class="cov0" title="0">{
                return err // Возвращаем ошибку от startHTTPServer
        }</span>
        <span class="cov0" title="0">return nil</span> // Успешное завершение run()
}

// setupDependencies инициализирует и возвращает все необходимые зависимости сервера.
func setupDependencies(cfg *config) (*dependencies, error) <span class="cov8" title="1">{
        deps := &amp;dependencies{}
        var err error

        // 1. Подключение к БД
        deps.db, err = newPostgresDB(cfg.DatabaseDSN)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("ошибка инициализации БД: %w", err)
        }</span>
        <span class="cov8" title="1">log.Println("Соединение с БД успешно установлено.")

        // 2. Инициализация клиента MinIO
        minioCfg := storage.MinioConfig{
                Endpoint:        getEnv(envMinioEndpoint, defaultMinioEndpoint),
                AccessKeyID:     getEnv(envMinioUser, defaultMinioUser),
                SecretAccessKey: getEnv(envMinioPassword, defaultMinioPassword),
                UseSSL:          minioUseSSL,
                BucketName:      getEnv(envMinioBucket, defaultMinioBucket),
        }
        // storage.NewMinioClient возвращает *storage.MinioClient, который реализует storage.FileStorage
        deps.fileStorage, err = storage.NewMinioClient(minioCfg)
        if err != nil </span><span class="cov8" title="1">{
                // Закрываем соединение с БД перед выходом
                if dbCloseErr := deps.db.Close(); dbCloseErr != nil </span><span class="cov8" title="1">{
                        log.Printf("Ошибка закрытия соединения с БД при ошибке MinIO: %v", dbCloseErr)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("ошибка инициализации клиента MinIO: %w", err)</span>
        }

        // 3. Создание репозиториев
        // Передаем *sqlx.DB в конструкторы репозиториев
        <span class="cov8" title="1">userRepo := repository.NewPostgresUserRepository(deps.db)
        vaultRepo := repository.NewPostgresVaultRepository(deps.db)
        vaultVersionRepo := repository.NewPostgresVaultVersionRepository(deps.db)

        // 4. Создание сервисов
        authService := services.NewAuthService(userRepo)
        // Передаем *sql.DB (из поля DB типа *sqlx.DB) в VaultService
        vaultService := services.NewVaultService(deps.db.DB, vaultRepo, vaultVersionRepo, deps.fileStorage)

        // 5. Создание обработчиков
        deps.authHandler = handlers.NewAuthHandler(authService)
        deps.vaultHandler = handlers.NewVaultHandler(vaultService)

        return deps, nil</span>
}

// setupRouter настраивает и возвращает роутер chi.
func setupRouter(authHandler *handlers.AuthHandler, vaultHandler *handlers.VaultHandler) *chi.Mux <span class="cov8" title="1">{
        r := chi.NewRouter()
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)

        // --- Маршруты --- //
        r.Get("/ping", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                _, _ = w.Write([]byte("pong\n"))
        }</span>)

        // Определяем базовый маршрут /api
        <span class="cov8" title="1">r.Route("/api", func(r chi.Router) </span><span class="cov8" title="1">{
                // Публичные маршруты (регистрация, вход)
                r.Post("/register", authHandler.Register)
                r.Post("/login", authHandler.Login)

                // Приватные маршруты (требуют аутентификации)
                r.Group(func(r chi.Router) </span><span class="cov8" title="1">{
                        // Применяем middleware аутентификации ко всей группе
                        r.Use(appmiddleware.Authenticator)

                        // Маршруты для работы с хранилищем
                        r.Route("/vault", func(r chi.Router) </span><span class="cov8" title="1">{
                                r.Get("/", vaultHandler.GetMetadata)
                                r.Post("/upload", vaultHandler.Upload)
                                r.Get("/download", vaultHandler.Download)
                                r.Get("/versions", vaultHandler.ListVersions)
                                r.Post("/rollback", vaultHandler.Rollback)
                        }</span>)
                        // Маршрут для удаления аккаунта (если он есть в AuthHandler)
                        // r.Delete("/account", authHandler.DeleteAccount)
                })
        })
        <span class="cov8" title="1">return r</span>
}

// getEnv получает значение переменной окружения или возвращает значение по умолчанию.
func getEnv(key, fallback string) string <span class="cov8" title="1">{
        if value, ok := os.LookupEnv(key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">log.Printf("Переменная окружения '%s' не установлена, используется значение по умолчанию: '%s'", key, fallback)
        return fallback</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "log"
        "net/http"

        "github.com/maynagashev/gophkeeper/models"                   // Импортируем наши модели
        "github.com/maynagashev/gophkeeper/server/internal/services" // Импортируем пакет сервисов
)

// AuthService определяет интерфейс для сервиса аутентификации.
// Это позволит нам легко подменять реализацию (например, для тестов).
// type AuthService interface { // Удаляем этот интерфейс отсюда
//         Register(username, password string) error
//         Login(username, password string) (string, error) // Возвращает JWT токен или ошибку
// }

// AuthHandler обрабатывает HTTP-запросы, связанные с аутентификацией.
type AuthHandler struct {
        service services.AuthService // Используем интерфейс из пакета services
}

// NewAuthHandler создает новый экземпляр AuthHandler.
func NewAuthHandler(s services.AuthService) *AuthHandler <span class="cov8" title="1">{ // Принимаем интерфейс из пакета services
        return &amp;AuthHandler{service: s}
}</span>

// Register обрабатывает запрос на регистрацию нового пользователя.
func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.RegisterRequest
        // Декодируем JSON из тела запроса
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                log.Printf("[AuthHandler] Ошибка декодирования запроса регистрации: %v", err)
                http.Error(w, "Неверный формат запроса", http.StatusBadRequest)
                return
        }</span>

        // Валидация входных данных (простая)
        <span class="cov8" title="1">if req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                log.Printf("[AuthHandler] Пустое имя пользователя или пароль при регистрации")
                http.Error(w, "Имя пользователя и пароль не могут быть пустыми", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[AuthHandler] Попытка регистрации пользователя: %s", req.Username)

        // Вызываем сервис
        err := h.service.Register(req.Username, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                // Обрабатываем ошибки от сервиса
                if errors.Is(err, services.ErrUsernameTaken) </span><span class="cov8" title="1">{
                        log.Printf("[AuthHandler] Ошибка регистрации (имя занято): %s", req.Username)
                        http.Error(w, err.Error(), http.StatusConflict) // 409 Conflict
                }</span> else<span class="cov8" title="1"> {
                        // Другие ошибки считаем внутренними
                        log.Printf("[AuthHandler] Внутренняя ошибка при регистрации '%s': %v", req.Username, err)
                        http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Возвращаем успешный статус
        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)                                // 201 Created
        _, _ = w.Write([]byte("Пользователь успешно зарегистрирован\n")) // Убираем "(заглушка)"
        log.Printf("[AuthHandler] Успешная регистрация для: %s", req.Username)</span>
}

// Login обрабатывает запрос на вход пользователя.
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.LoginRequest
        // Декодируем JSON из тела запроса
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                log.Printf("[AuthHandler] Ошибка декодирования запроса входа: %v", err)
                http.Error(w, "Неверный формат запроса", http.StatusBadRequest)
                return
        }</span>

        // Валидация входных данных (простая)
        <span class="cov8" title="1">if req.Username == "" || req.Password == "" </span><span class="cov8" title="1">{
                log.Printf("[AuthHandler] Пустое имя пользователя или пароль при входе")
                http.Error(w, "Имя пользователя и пароль не могут быть пустыми", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[AuthHandler] Попытка входа пользователя: %s", req.Username)

        // Вызываем сервис
        token, err := h.service.Login(req.Username, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                // Обрабатываем ошибки от сервиса
                if errors.Is(err, services.ErrInvalidCredentials) </span><span class="cov8" title="1">{
                        log.Printf("[AuthHandler] Ошибка входа (неверные данные): %s", req.Username)
                        http.Error(w, err.Error(), http.StatusUnauthorized) // 401 Unauthorized
                }</span> else<span class="cov8" title="1"> {
                        // Другие ошибки считаем внутренними
                        log.Printf("[AuthHandler] Внутренняя ошибка при входе '%s': %v", req.Username, err)
                        http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Возвращаем токен
        <span class="cov8" title="1">resp := models.LoginResponse{
                Token: token, // Используем реальный токен от сервиса
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK) // 200 OK
        if err = json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                log.Printf("[AuthHandler] Ошибка кодирования ответа входа: %v", err)
                return
        }</span>
        <span class="cov8" title="1">log.Printf("[AuthHandler] Успешный вход для: %s", req.Username)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "io"
        "log"
        "net/http"
        "strconv"
        "time"

        "github.com/maynagashev/gophkeeper/models"
        "github.com/maynagashev/gophkeeper/server/internal/middleware"
        "github.com/maynagashev/gophkeeper/server/internal/services"
)

// VaultHandler обрабатывает HTTP-запросы, связанные с хранилищем.
type VaultHandler struct {
        vaultService services.VaultService
}

// NewVaultHandler создает новый экземпляр VaultHandler.
func NewVaultHandler(vs services.VaultService) *VaultHandler <span class="cov8" title="1">{
        return &amp;VaultHandler{vaultService: vs}
}</span>

// GetMetadata обрабатывает GET запрос на получение метаданных ТЕКУЩЕЙ версии хранилища.
func (h *VaultHandler) GetMetadata(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := middleware.GetUserIDFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:GetMetadata] Не удалось получить userID из контекста")
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultHandler:GetMetadata] Запрос метаданных от пользователя %d", userID)

        // Вызываем сервис для получения метаданных ТЕКУЩЕЙ версии
        currentVersion, err := h.vaultService.GetVaultMetadata(userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, services.ErrVaultNotFound) </span><span class="cov8" title="1">{
                        log.Printf("[VaultHandler:GetMetadata] Метаданные не найдены для пользователя %d", userID)
                        http.Error(w, "Хранилище не найдено", http.StatusNotFound)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("[VaultHandler:GetMetadata] Внутренняя ошибка "+
                                "при получении метаданных для пользователя %d: %v", userID, err)
                        http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Отправляем метаданные текущей версии в JSON
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err = json.NewEncoder(w).Encode(currentVersion); err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultHandler:GetMetadata] Ошибка кодирования ответа с метаданными: %v", err)
        }</span>
}

// Upload обрабатывает POST запрос на загрузку файла хранилища.
func (h *VaultHandler) Upload(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Получаем ID пользователя из контекста
        userID, ok := middleware.GetUserIDFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Upload] Не удалось получить userID из контекста")
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultHandler:Upload] Запрос на загрузку файла от пользователя %d", userID)

        // === Чтение заголовка X-Kdbx-Content-Modified-At ===
        contentModTimeStr := r.Header.Get("X-Kdbx-Content-Modified-At")
        if contentModTimeStr == "" </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Upload] Отсутствует обязательный заголовок X-Kdbx-Content-Modified-At")
                http.Error(w, "Отсутствует обязательный заголовок X-Kdbx-Content-Modified-At", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">contentModTime, err := time.Parse(time.RFC3339, contentModTimeStr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Upload] Ошибка парсинга заголовка "+
                        "X-Kdbx-Content-Modified-At ('%s'): %v", contentModTimeStr, err)
                http.Error(w, "Неверный формат заголовка X-Kdbx-Content-Modified-At (ожидается RFC3339)", http.StatusBadRequest)
                return
        }</span>
        // ===================================================

        // Получаем размер файла из заголовка Content-Length
        <span class="cov8" title="1">sizeStr := r.Header.Get("Content-Length")
        size, err := strconv.ParseInt(sizeStr, 10, 64)
        if err != nil || size &lt;= 0 </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Upload] Неверный или отсутствующий заголовок Content-Length: %s", sizeStr)
                http.Error(w, "Неверный или отсутствующий заголовок Content-Length", http.StatusBadRequest)
                return
        }</span>

        // Получаем Content-Type
        <span class="cov8" title="1">contentType := r.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                // По умолчанию считаем бинарным потоком
                contentType = "application/octet-stream"
        }</span>

        // Вызываем сервис для загрузки файла, передавая contentModTime
        <span class="cov8" title="1">err = h.vaultService.UploadVault(userID, r.Body, size, contentType, contentModTime)
        if err != nil </span><span class="cov8" title="1">{
                // Обработка ошибок сервиса
                if errors.Is(err, services.ErrConflictVersion) </span><span class="cov0" title="0">{
                        log.Printf("[VaultHandler:Upload] Конфликт версии при загрузке файла для пользователя %d: %v", userID, err)
                        // Формируем строку ошибки для переноса
                        conflictMsg := "Конфликт версий: на сервере уже есть более новая " +
                                "или идентичная версия с другим содержимым."
                        http.Error(w, conflictMsg, http.StatusConflict)
                }</span> else<span class="cov8" title="1"> {
                        // Другие ошибки считаем внутренними
                        log.Printf("[VaultHandler:Upload] Ошибка сервиса при загрузке файла для пользователя %d: %v", userID, err)
                        http.Error(w, "Внутренняя ошибка сервера при загрузке файла", http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // Успешный ответ (даже если версия была идентичной и не создавалась новая)
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte("Файл успешно загружен\n")) // TODO: Возможно, стоит вернуть ID версии как в api.md?
        log.Printf("[VaultHandler:Upload] Файл для пользователя %d успешно загружен", userID)</span>
}

// Download обрабатывает GET запрос на скачивание ТЕКУЩЕЙ версии файла хранилища.
func (h *VaultHandler) Download(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := middleware.GetUserIDFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Download] Не удалось получить userID из контекста")
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultHandler:Download] Запрос на скачивание файла от пользователя %d", userID)

        // Вызываем сервис для скачивания ТЕКУЩЕЙ версии
        fileReader, versionMeta, err := h.vaultService.DownloadVault(userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, services.ErrVaultNotFound) </span><span class="cov8" title="1">{
                        log.Printf("[VaultHandler:Download] Хранилище/версия не найдено для пользователя %d", userID)
                        http.Error(w, "Хранилище не найдено", http.StatusNotFound)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("[VaultHandler:Download] Внутренняя ошибка при скачивании "+
                                "файла для пользователя %d: %v", userID, err)
                        http.Error(w, "Внутренняя ошибка сервера при скачивании файла", http.StatusInternalServerError)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := fileReader.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("[VaultHandler:Download] Ошибка закрытия fileReader: %v", closeErr)
                }</span>
        }()

        // Устанавливаем заголовки для скачивания файла
        <span class="cov8" title="1">w.Header().Set("Content-Disposition", `attachment; filename="gophkeeper_vault.kdbx"`)
        contentType := "application/octet-stream"
        w.Header().Set("Content-Type", contentType)
        if versionMeta.SizeBytes != nil </span><span class="cov8" title="1">{
                w.Header().Set("Content-Length", strconv.FormatInt(*versionMeta.SizeBytes, 10))
        }</span>

        // Копируем данные из fileReader в ResponseWriter
        <span class="cov8" title="1">_, err = io.Copy(w, fileReader)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultHandler:Download] Ошибка копирования данных файла в ответ для пользователя %d: %v", userID, err)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultHandler:Download] Файл для пользователя %d (версия %d) успешно отправлен", userID, versionMeta.ID)</span>
}

// ListVersions обрабатывает GET запрос на получение списка версий хранилища.
func (h *VaultHandler) ListVersions(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := middleware.GetUserIDFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:ListVersions] Не удалось получить userID из контекста")
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        // Получаем параметры пагинации (простой вариант, без валидации)
        <span class="cov8" title="1">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")
        limit, _ := strconv.Atoi(limitStr)
        offset, _ := strconv.Atoi(offsetStr)
        if limit &lt;= 0 || limit &gt; 100 </span><span class="cov8" title="1">{ // Ограничиваем максимальный лимит
                limit = 20 // Значение по умолчанию
        }</span>
        <span class="cov8" title="1">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultHandler:ListVersions] Запрос списка версий от пользователя %d "+
                "(limit=%d, offset=%d)", userID, limit, offset)

        versions, err := h.vaultService.ListVersions(userID, limit, offset)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:ListVersions] Внутренняя ошибка при получении "+
                        "списка версий для пользователя %d: %v", userID, err)
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        // --- Формирование ответа с учетом current_version_id ---
        // Получаем ID текущей версии, чтобы добавить его в ответ
        <span class="cov8" title="1">currentVersionMeta, err := h.vaultService.GetVaultMetadata(userID)
        var currentVersionID *int64
        if err == nil &amp;&amp; currentVersionMeta != nil </span><span class="cov8" title="1">{ // Если ошибки нет и метаданные получены
                cvID := currentVersionMeta.ID // Копируем значение ID
                currentVersionID = &amp;cvID
        }</span> else<span class="cov8" title="1"> if err != nil &amp;&amp; !errors.Is(err, services.ErrVaultNotFound) </span><span class="cov0" title="0">{
                // Если произошла другая ошибка при получении метаданных
                log.Printf("[VaultHandler:ListVersions] Ошибка при получении current_version_id для ответа: %v", err)
                // Не прерываем выполнение, просто currentVersionID будет nil
        }</span>

        // Структура ответа для /versions
        <span class="cov8" title="1">type listVersionsResponse struct {
                Versions         []models.VaultVersion `json:"versions"`
                CurrentVersionID *int64                `json:"current_version_id,omitempty"`
        }

        response := listVersionsResponse{
                Versions:         versions,
                CurrentVersionID: currentVersionID,
        }

        // Отправляем список версий в JSON
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err = json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{ // Отправляем новую структуру
                log.Printf("[VaultHandler:ListVersions] Ошибка кодирования ответа со списком версий: %v", err)
        }</span>
}

// RollbackRequest представляет тело запроса на откат к версии.
type RollbackRequest struct {
        VersionID int64 `json:"version_id"`
}

// Rollback обрабатывает POST запрос на откат к указанной версии.
func (h *VaultHandler) Rollback(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userID, ok := middleware.GetUserIDFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Rollback] Не удалось получить userID из контекста")
                http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
                return
        }</span>

        // Декодируем тело запроса
        <span class="cov8" title="1">var req RollbackRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                log.Printf("[VaultHandler:Rollback] Ошибка декодирования запроса на откат: %v", err)
                http.Error(w, "Неверный формат запроса", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if req.VersionID &lt;= 0 </span><span class="cov8" title="1">{
                http.Error(w, "Неверный ID версии", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultHandler:Rollback] Запрос на откат к версии %d от пользователя %d", req.VersionID, userID)

        err := h.vaultService.RollbackToVersion(userID, req.VersionID)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, services.ErrVaultNotFound), errors.Is(err, services.ErrVersionNotFound):<span class="cov8" title="1">
                        log.Printf("[VaultHandler:Rollback] Хранилище/версия %d не найдена для пользователя %d", req.VersionID, userID)
                        http.Error(w, "Указанное хранилище или версия не найдены", http.StatusNotFound)</span>
                case errors.Is(err, services.ErrForbidden):<span class="cov8" title="1">
                        log.Printf("[VaultHandler:Rollback] Попытка отката к чужой версии %d пользователем %d", req.VersionID, userID)
                        http.Error(w, "Доступ запрещен", http.StatusForbidden)</span>
                default:<span class="cov8" title="1">
                        log.Printf("[VaultHandler:Rollback] Внутренняя ошибка при откате "+
                                "к версии %d для пользователя %d: %v", req.VersionID, userID, err)
                        http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent) // 204 No Content - успешный откат без тела ответа
        log.Printf("[VaultHandler:Rollback] Успешный откат к версии %d для пользователя %d", req.VersionID, userID)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "strings"

        "github.com/golang-jwt/jwt/v5"
)

// Тип для ключа контекста.
type contextKey string

// Ключ для хранения ID пользователя в контексте.
const UserIDKey contextKey = "userID"

// TODO: Вынести секретный ключ в конфигурацию/переменные окружения! (Дублируется с services)
const jwtSecretKey = "your-very-secret-key"

// Структура для пользовательских данных в JWT (claims) - должна совпадать с той, что в services.
type jwtClaims struct {
        UserID int64 `json:"user_id"`
        jwt.RegisteredClaims
}

// Authenticator проверяет JWT токен аутентификации.
func Authenticator(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Получаем заголовок Authorization
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        log.Println("[AuthMiddleware] Заголовок Authorization отсутствует")
                        http.Error(w, "Требуется аутентификация", http.StatusUnauthorized)
                        return
                }</span>

                // Проверяем формат "Bearer token"
                <span class="cov0" title="0">headerParts := strings.Split(authHeader, " ")
                if len(headerParts) != 2 || strings.ToLower(headerParts[0]) != "bearer" </span><span class="cov0" title="0">{
                        log.Printf("[AuthMiddleware] Неверный формат заголовка Authorization: %s", authHeader)
                        http.Error(w, "Неверный формат токена", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">tokenString := headerParts[1]

                // Парсим и валидируем токен
                claims := &amp;jwtClaims{}
                token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        // Убеждаемся, что метод подписи - HS256
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("неожиданный метод подписи: %v", token.Header["alg"])
                        }</span>
                        // Возвращаем секретный ключ
                        <span class="cov0" title="0">return []byte(jwtSecretKey), nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[AuthMiddleware] Ошибка парсинга/валидации токена: %v", err)
                        http.Error(w, "Невалидный токен", http.StatusUnauthorized)
                        return
                }</span>

                // Проверяем валидность токена (включая время жизни, issuer и т.д.)
                <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                        log.Println("[AuthMiddleware] Предоставлен невалидный токен (возможно, истек)")
                        http.Error(w, "Невалидный токен", http.StatusUnauthorized)
                        return
                }</span>

                // Добавляем UserID в контекст запроса
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), UserIDKey, claims.UserID)

                // Логируем успешную аутентификацию
                log.Printf("[AuthMiddleware] Пользователь %d успешно аутентифицирован", claims.UserID)

                // Передаем управление следующему обработчику с обновленным контекстом
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// GetUserIDFromContext извлекает UserID из контекста запроса.
// Возвращает ID пользователя и true, если ID найден, иначе 0 и false.
func GetUserIDFromContext(ctx context.Context) (int64, bool) <span class="cov0" title="0">{
        userID, ok := ctx.Value(UserIDKey).(int64)
        return userID, ok
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "fmt"
        "log"
        "time"

        "github.com/jmoiron/sqlx"
        _ "github.com/lib/pq" // Драйвер PostgreSQL, импортируем для регистрации
)

const (
        maxOpenConns    = 25              // Максимальное количество открытых соединений
        maxIdleConns    = 25              // Максимальное количество простаивающих соединений
        connMaxLifetime = 5 * time.Minute // Максимальное время жизни соединения
        connMaxIdleTime = 5 * time.Minute // Максимальное время простоя соединения
)

// NewPostgresDB создает и возвращает новое подключение к PostgreSQL.
func NewPostgresDB(dsn string) (*sqlx.DB, error) <span class="cov0" title="0">{
        log.Printf("Подключение к PostgreSQL...")

        db, err := sqlx.Connect("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка подключения к БД: %w", err)
        }</span>

        // Проверка соединения
        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                // Закрываем соединение в случае ошибки пинга
                closeErr := db.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Ошибка закрытия соединения с БД после неудачного пинга: %v", closeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("ошибка проверки соединения с БД (ping): %w", err)</span>
        }

        // Настройка пула соединений
        <span class="cov0" title="0">db.SetMaxOpenConns(maxOpenConns)
        db.SetMaxIdleConns(maxIdleConns)
        db.SetConnMaxLifetime(connMaxLifetime)
        db.SetConnMaxIdleTime(connMaxIdleTime)

        log.Println("Подключение к PostgreSQL успешно установлено.")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"

        "github.com/jmoiron/sqlx"
        "github.com/lib/pq"
        "github.com/maynagashev/gophkeeper/models"
)

// Коды ошибок PostgreSQL.
const (
        pgUniqueViolationCode = "23505"
)

// UserRepository определяет методы для работы с данными пользователей в хранилище.
type UserRepository interface {
        CreateUser(ctx context.Context, user *models.User) (int64, error)
        GetUserByUsername(ctx context.Context, username string) (*models.User, error)
}

// postgresUserRepository реализует UserRepository для PostgreSQL.
type postgresUserRepository struct {
        db *sqlx.DB
}

// NewPostgresUserRepository создает новый экземпляр репозитория пользователей для PostgreSQL.
func NewPostgresUserRepository(db *sqlx.DB) UserRepository <span class="cov0" title="0">{
        return &amp;postgresUserRepository{db: db}
}</span>

// CreateUser создает нового пользователя в базе данных.
// Возвращает ID созданного пользователя или ошибку.
func (r *postgresUserRepository) CreateUser(ctx context.Context, user *models.User) (int64, error) <span class="cov0" title="0">{
        query := `INSERT INTO users (username, password_hash) VALUES ($1, $2) RETURNING id`
        var userID int64

        err := r.db.QueryRowxContext(ctx, query, user.Username, user.PasswordHash).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                // Проверяем на ошибку нарушения уникальности (duplicate key)
                var pgErr *pq.Error
                if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == pgUniqueViolationCode </span><span class="cov0" title="0">{
                        log.Printf("[Repo] Ошибка создания пользователя: имя пользователя '%s' уже занято", user.Username)
                        return 0, ErrUsernameTaken // Возвращаем кастомную ошибку
                }</span>
                <span class="cov0" title="0">log.Printf("[Repo] Непредвиденная ошибка при создании пользователя '%s': %v", user.Username, err)
                return 0, fmt.Errorf("ошибка выполнения запроса на создание пользователя: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("[Repo] Пользователь '%s' успешно создан с ID %d", user.Username, userID)
        return userID, nil</span>
}

// GetUserByUsername находит пользователя по его имени.
// Возвращает пользователя или ошибку, если пользователь не найден или произошла другая ошибка.
func (r *postgresUserRepository) GetUserByUsername(ctx context.Context, username string) (*models.User, error) <span class="cov0" title="0">{
        query := `SELECT id, username, password_hash, created_at, updated_at FROM users WHERE username=$1`
        var user models.User

        err := r.db.GetContext(ctx, &amp;user, query, username)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        log.Printf("[Repo] Пользователь с именем '%s' не найден", username)
                        return nil, ErrUserNotFound // Пользователь не найден
                }</span>
                <span class="cov0" title="0">log.Printf("[Repo] Ошибка при поиске пользователя '%s': %v", username, err)
                return nil, fmt.Errorf("ошибка выполнения запроса на получение пользователя: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("[Repo] Найден пользователь '%s' (ID: %d)", username, user.ID)
        return &amp;user, nil</span>
}

// Кастомные ошибки репозитория.
var (
        ErrUserNotFound  = errors.New("пользователь не найден")
        ErrUsernameTaken = errors.New("имя пользователя уже занято")
)
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/jmoiron/sqlx"
        "github.com/maynagashev/gophkeeper/models"
        // "github.com/lib/pq" // Больше не нужен здесь, т.к. убрали CreateVault/UpdateVaultMetadata с проверкой UNIQUE.
)

// VaultRepository определяет методы для работы с основными записями хранилищ.
type VaultRepository interface {
        GetVaultByUserID(ctx context.Context, userID int64) (*models.Vault, error)
        CreateVault(ctx context.Context, vault *models.Vault) (int64, error)
        UpdateVaultCurrentVersion(ctx context.Context, vaultID int64, versionID int64) error
        GetVaultWithCurrentVersionByUserID(ctx context.Context, userID int64) (*models.Vault, *models.VaultVersion, error)
}

// postgresVaultRepository реализует VaultRepository для PostgreSQL.
type postgresVaultRepository struct {
        db *sqlx.DB
}

// NewPostgresVaultRepository создает новый экземпляр репозитория хранилищ.
func NewPostgresVaultRepository(db *sqlx.DB) VaultRepository <span class="cov0" title="0">{
        return &amp;postgresVaultRepository{db: db}
}</span>

// GetVaultByUserID находит основную запись хранилища по ID пользователя.
func (r *postgresVaultRepository) GetVaultByUserID(ctx context.Context, userID int64) (*models.Vault, error) <span class="cov0" title="0">{
        query := `SELECT id, user_id, current_version_id, created_at, updated_at FROM vaults WHERE user_id=$1 LIMIT 1`
        var vault models.Vault

        err := r.db.GetContext(ctx, &amp;vault, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        log.Printf("[VaultRepo] Хранилище для пользователя ID %d не найдено", userID)
                        return nil, ErrVaultNotFound
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultRepo] Ошибка при поиске хранилища для пользователя ID %d: %v", userID, err)
                return nil, fmt.Errorf("ошибка выполнения запроса на получение хранилища: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("[VaultRepo] Найдено хранилище (ID: %d) для пользователя ID %d", vault.ID, userID)
        return &amp;vault, nil</span>
}

// CreateVault создает новую основную запись о хранилище для пользователя.
// Поле current_version_id будет NULL по умолчанию.
func (r *postgresVaultRepository) CreateVault(ctx context.Context, vault *models.Vault) (int64, error) <span class="cov0" title="0">{
        // Убедимся, что current_version_id не передается при создании
        query := `INSERT INTO vaults (user_id) VALUES ($1) RETURNING id`
        var vaultID int64

        err := r.db.QueryRowxContext(ctx, query, vault.UserID).Scan(&amp;vaultID)
        if err != nil </span><span class="cov0" title="0">{
                // Здесь может быть ошибка уникальности user_id, если мы добавим такой constraint
                log.Printf("[VaultRepo] Непредвиденная ошибка при создании хранилища для пользователя ID %d: %v", vault.UserID, err)
                return 0, fmt.Errorf("ошибка выполнения запроса на создание хранилища: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[VaultRepo] Хранилище (ID: %d) успешно создано для пользователя ID %d", vaultID, vault.UserID)
        return vaultID, nil</span>
}

// UpdateVaultCurrentVersion обновляет ссылку на текущую версию в записи хранилища.
func (r *postgresVaultRepository) UpdateVaultCurrentVersion(ctx context.Context, vaultID int64, versionID int64) error <span class="cov0" title="0">{
        query := `UPDATE vaults SET current_version_id=$1, updated_at=NOW() WHERE id=$2`

        result, err := r.db.ExecContext(ctx, query, versionID, vaultID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultRepo] Ошибка обновления current_version_id для хранилища ID %d: %v", vaultID, err)
                return fmt.Errorf("ошибка выполнения запроса на обновление current_version_id: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultRepo] Ошибка получения rowsAffected при обновлении"+
                        " current_version_id для хранилища ID %d: %v", vaultID, err)
                return fmt.Errorf("ошибка получения результата обновления current_version_id: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                log.Printf("[VaultRepo] Хранилище ID %d не найдено для обновления current_version_id", vaultID)
                return ErrVaultNotFound
        }</span>

        <span class="cov0" title="0">log.Printf("[VaultRepo] current_version_id для хранилища ID %d успешно обновлен на %d", vaultID, versionID)
        return nil</span>
}

// GetVaultWithCurrentVersionByUserID получает запись хранилища и данные его текущей версии одним запросом.
func (r *postgresVaultRepository) GetVaultWithCurrentVersionByUserID(
        ctx context.Context,
        userID int64,
) (*models.Vault, *models.VaultVersion, error) <span class="cov0" title="0">{
        // Добавили выборку vv.content_modified_at
        query := `
                SELECT
                    v.id AS vault_id, v.user_id, v.created_at AS vault_created_at, v.updated_at AS vault_updated_at,
                    vv.id AS version_id, vv.object_key, vv.checksum, vv.size_bytes,
                    vv.created_at AS version_created_at, vv.content_modified_at AS version_content_modified_at
                FROM vaults v
                LEFT JOIN vault_versions vv ON v.current_version_id = vv.id
                WHERE v.user_id = $1
                LIMIT 1`

        // Используем временную структуру для сканирования результата JOIN
        // Добавили поле для content_modified_at
        type result struct {
                VaultID                  int64      `db:"vault_id"`
                UserID                   int64      `db:"user_id"`
                VaultCreatedAt           time.Time  `db:"vault_created_at"`
                VaultUpdatedAt           time.Time  `db:"vault_updated_at"`
                VersionID                *int64     `db:"version_id"` // Указатель, т.к. LEFT JOIN может дать NULL
                ObjectKey                *string    `db:"object_key"`
                Checksum                 *string    `db:"checksum"`
                SizeBytes                *int64     `db:"size_bytes"`
                VersionCreatedAt         *time.Time `db:"version_created_at"`
                VersionContentModifiedAt *time.Time `db:"version_content_modified_at"` // Указатель, т.к. LEFT JOIN может дать NULL
        }

        var res result
        err := r.db.GetContext(ctx, &amp;res, query, userID)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        log.Printf("[VaultRepo] Хранилище (с версией) для пользователя ID %d не найдено", userID)
                        return nil, nil, ErrVaultNotFound
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultRepo] Ошибка при поиске хранилища с версией для пользователя ID %d: %v", userID, err)
                return nil, nil, fmt.Errorf("ошибка выполнения запроса на получение хранилища с версией: %w", err)</span>
        }

        <span class="cov0" title="0">vault := &amp;models.Vault{
                ID:               res.VaultID,
                UserID:           res.UserID,
                CurrentVersionID: res.VersionID, // Передаем указатель
                CreatedAt:        res.VaultCreatedAt,
                UpdatedAt:        res.VaultUpdatedAt,
        }

        var currentVersion *models.VaultVersion
        if res.VersionID != nil </span><span class="cov0" title="0">{ // Если есть текущая версия
                // Добавили заполнение ContentModifiedAt
                currentVersion = &amp;models.VaultVersion{
                        ID:                *res.VersionID,
                        VaultID:           res.VaultID,
                        ObjectKey:         *res.ObjectKey,
                        Checksum:          res.Checksum,
                        SizeBytes:         res.SizeBytes,
                        CreatedAt:         *res.VersionCreatedAt,
                        ContentModifiedAt: res.VersionContentModifiedAt, // Указатель на время или nil
                }
                log.Printf("[VaultRepo] Найдено хранилище ID %d с текущей версией ID %d"+
                        " для пользователя %d", vault.ID, currentVersion.ID, userID)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("[VaultRepo] Найдено хранилище ID %d без текущей версии для пользователя %d", vault.ID, userID)
        }</span>

        <span class="cov0" title="0">return vault, currentVersion, nil</span>
}

// Кастомная ошибка репозитория.
var (
        ErrVaultNotFound = errors.New("метаданные хранилища не найдены")
)
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"

        "github.com/jmoiron/sqlx"
        "github.com/lib/pq"
        "github.com/maynagashev/gophkeeper/models"
)

// VaultVersionRepository определяет методы для работы с версиями хранилищ.
type VaultVersionRepository interface {
        CreateVersion(ctx context.Context, version *models.VaultVersion) (int64, error)
        ListVersionsByVaultID(ctx context.Context, vaultID int64, limit, offset int) ([]models.VaultVersion, error)
        GetVersionByID(ctx context.Context, versionID int64) (*models.VaultVersion, error)
}

// postgresVaultVersionRepository реализует VaultVersionRepository для PostgreSQL.
type postgresVaultVersionRepository struct {
        db *sqlx.DB
}

// NewPostgresVaultVersionRepository создает новый экземпляр репозитория версий.
func NewPostgresVaultVersionRepository(db *sqlx.DB) VaultVersionRepository <span class="cov0" title="0">{
        return &amp;postgresVaultVersionRepository{db: db}
}</span>

// CreateVersion создает новую запись о версии хранилища.
func (r *postgresVaultVersionRepository) CreateVersion(
        ctx context.Context,
        version *models.VaultVersion,
) (int64, error) <span class="cov0" title="0">{
        query := `INSERT INTO vault_versions (vault_id, object_key, checksum, size_bytes, content_modified_at)
                  VALUES ($1, $2, $3, $4, $5) RETURNING id`
        var versionID int64

        err := r.db.QueryRowxContext(ctx, query,
                version.VaultID, version.ObjectKey, version.Checksum, version.SizeBytes, version.ContentModifiedAt,
        ).Scan(&amp;versionID)

        if err != nil </span><span class="cov0" title="0">{
                // Проверяем на ошибку уникальности object_key
                var pgErr *pq.Error
                if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == pgUniqueViolationCode </span><span class="cov0" title="0">{
                        log.Printf("[VaultVerRepo] Ошибка создания версии: ключ объекта '%s' уже существует", version.ObjectKey)
                        return 0, fmt.Errorf("версия с ключом объекта '%s' уже существует: %w", version.ObjectKey, err)
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultVerRepo] Непредвиденная ошибка при создании версии для '%s': %v", version.ObjectKey, err)
                return 0, fmt.Errorf("ошибка выполнения запроса на создание версии: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("[VaultVerRepo] Версия (ID: %d) успешно создана для хранилища ID %d", versionID, version.VaultID)
        return versionID, nil</span>
}

// ListVersionsByVaultID возвращает список версий для указанного хранилища с пагинацией.
func (r *postgresVaultVersionRepository) ListVersionsByVaultID(
        ctx context.Context,
        vaultID int64,
        limit,
        offset int,
) ([]models.VaultVersion, error) <span class="cov0" title="0">{
        // Запрос с сортировкой по убыванию времени создания (сначала новые)
        query := `SELECT id, vault_id, object_key, checksum, size_bytes, created_at, content_modified_at
                  FROM vault_versions
                  WHERE vault_id=$1
                  ORDER BY created_at DESC
                  LIMIT $2 OFFSET $3`

        versions := make([]models.VaultVersion, 0, limit)
        err := r.db.SelectContext(ctx, &amp;versions, query, vaultID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultVerRepo] Ошибка при получении списка версий для хранилища ID %d: %v", vaultID, err)
                return nil, fmt.Errorf("ошибка выполнения запроса на получение списка версий: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[VaultVerRepo] Получено %d версий для хранилища ID %d (limit=%d, offset=%d)",
                len(versions), vaultID, limit, offset)
        return versions, nil</span>
}

// GetVersionByID находит конкретную версию по ее ID.
func (r *postgresVaultVersionRepository) GetVersionByID(
        ctx context.Context,
        versionID int64,
) (*models.VaultVersion, error) <span class="cov0" title="0">{
        query := `SELECT id, vault_id, object_key, checksum, size_bytes, created_at, content_modified_at` +
                ` FROM vault_versions WHERE id=$1`
        var version models.VaultVersion

        err := r.db.GetContext(ctx, &amp;version, query, versionID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        log.Printf("[VaultVerRepo] Версия с ID %d не найдена", versionID)
                        return nil, ErrVersionNotFound // Кастомная ошибка
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultVerRepo] Ошибка при поиске версии ID %d: %v", versionID, err)
                return nil, fmt.Errorf("ошибка выполнения запроса на получение версии: %w", err)</span>
        }

        <span class="cov0" title="0">log.Printf("[VaultVerRepo] Найдена версия ID %d (Хранилище ID: %d)", versionID, version.VaultID)
        return &amp;version, nil</span>
}

// Кастомные ошибки репозитория версий.
var (
        ErrVersionNotFound = errors.New("версия хранилища не найдена") // Возвращаем определение
)
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/maynagashev/gophkeeper/models"
        "github.com/maynagashev/gophkeeper/server/internal/repository"
        "golang.org/x/crypto/bcrypt"
)

// AuthService определяет интерфейс для сервиса аутентификации.
type AuthService interface {
        Register(username, password string) error
        Login(username, password string) (string, error) // Возвращает JWT токен или ошибку
}

// Константы для JWT.
const (
        // TODO: Вынести секретный ключ в конфигурацию/переменные окружения!
        jwtSecretKey = "your-very-secret-key"
        tokenTTL     = time.Hour * 24 // Время жизни токена - 24 часа
)

// Структура для пользовательских данных в JWT (claims).
type jwtClaims struct {
        UserID int64 `json:"user_id"`
        jwt.RegisteredClaims
}

// Убедимся, что authService удовлетворяет интерфейсу AuthService.
var _ AuthService = (*authService)(nil)

type authService struct {
        userRepo repository.UserRepository // Зависимость от репозитория пользователей
}

// NewAuthService создает новый экземпляр сервиса аутентификации.
func NewAuthService(userRepo repository.UserRepository) AuthService <span class="cov0" title="0">{ // Возвращаем интерфейс
        return &amp;authService{userRepo: userRepo}
}</span>

// Register регистрирует нового пользователя.
func (s *authService) Register(username, password string) error <span class="cov0" title="0">{
        ctx := context.Background() // Используем фоновый контекст для операций сервиса

        // Хешируем пароль
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[AuthService] Ошибка хеширования пароля для '%s': %v", username, err)
                return errors.New("внутренняя ошибка сервера при хешировании пароля")
        }</span>

        <span class="cov0" title="0">user := &amp;models.User{
                Username:     username,
                PasswordHash: string(hashedPassword),
        }

        // Создаем пользователя через репозиторий
        _, err = s.userRepo.CreateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrUsernameTaken) </span><span class="cov0" title="0">{
                        log.Printf("[AuthService] Попытка регистрации с занятым именем: %s", username)
                        return ErrUsernameTaken // Возвращаем ошибку слоя сервиса
                }</span>
                <span class="cov0" title="0">log.Printf("[AuthService] Непредвиденная ошибка репозитория при регистрации '%s': %v", username, err)
                return errors.New("внутренняя ошибка сервера при создании пользователя")</span>
        }

        <span class="cov0" title="0">log.Printf("[AuthService] Пользователь '%s' успешно зарегистрирован", username)
        return nil</span>
}

// Login аутентифицирует пользователя и возвращает JWT токен.
func (s *authService) Login(username, password string) (string, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Получаем пользователя по имени пользователя
        user, err := s.userRepo.GetUserByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrUserNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[AuthService] Попытка входа несуществующего пользователя: %s", username)
                        return "", ErrInvalidCredentials // Общая ошибка для несуществующего пользователя и неверного пароля
                }</span>
                <span class="cov0" title="0">log.Printf("[AuthService] Ошибка репозитория при поиске '%s': %v", username, err)
                return "", errors.New("внутренняя ошибка сервера при поиске пользователя")</span>
        }

        // Сравниваем предоставленный пароль с хешем из базы данных
        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                // Ошибка сравнения означает неверный пароль (или другую проблему bcrypt)
                log.Printf("[AuthService] Неверный пароль для пользователя: %s", username)
                return "", ErrInvalidCredentials // Общая ошибка
        }</span>

        // Генерируем JWT токен
        <span class="cov0" title="0">token, err := s.generateJWT(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[AuthService] Ошибка генерации JWT для '%s': %v", username, err)
                return "", errors.New("внутренняя ошибка сервера при генерации токена")
        }</span>

        <span class="cov0" title="0">log.Printf("[AuthService] Пользователь '%s' успешно аутентифицирован", username)
        return token, nil</span>
}

// generateJWT создает и подписывает JWT токен для пользователя.
func (s *authService) generateJWT(userID int64) (string, error) <span class="cov0" title="0">{
        // Создаем claims (полезную нагрузку)
        claims := jwtClaims{
                UserID: userID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(tokenTTL)), // Время истечения
                        IssuedAt:  jwt.NewNumericDate(time.Now()),               // Время выдачи
                        NotBefore: jwt.NewNumericDate(time.Now()),               // Время, с которого токен валиден
                        Issuer:    "gophkeeper-server",                          // Источник токена
                },
        }

        // Создаем токен с нашими claims и методом подписи HS256
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        // Подписываем токен секретным ключом
        signedToken, err := token.SignedString([]byte(jwtSecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ошибка подписи JWT: %w", err)
        }</span>

        <span class="cov0" title="0">return signedToken, nil</span>
}

// Кастомные ошибки сервиса.
var (
        ErrInvalidCredentials = errors.New("неверное имя пользователя или пароль")
        ErrUsernameTaken      = errors.New("имя пользователя уже занято")
)
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "log"
        "time"

        "github.com/google/uuid"
        "github.com/maynagashev/gophkeeper/models"
        "github.com/maynagashev/gophkeeper/server/internal/repository"
        "github.com/maynagashev/gophkeeper/server/internal/storage"
)

// VaultService определяет интерфейс для сервиса работы с хранилищами.
type VaultService interface {
        GetVaultMetadata(userID int64) (*models.VaultVersion, error)
        UploadVault(userID int64, reader io.Reader, size int64, contentType string, contentModifiedAt time.Time) error
        DownloadVault(userID int64) (io.ReadCloser, *models.VaultVersion, error)
        ListVersions(userID int64, limit, offset int) ([]models.VaultVersion, error)
        RollbackToVersion(userID int64, versionID int64) error
}

// vaultService реализует логику работы с хранилищами.
var _ VaultService = (*vaultService)(nil)

type vaultService struct {
        db               *sql.DB
        vaultRepo        repository.VaultRepository
        vaultVersionRepo repository.VaultVersionRepository
        fileStorage      storage.FileStorage
}

// NewVaultService создает новый экземпляр сервиса хранилищ.
func NewVaultService(
        db *sql.DB,
        vaultRepo repository.VaultRepository,
        vaultVersionRepo repository.VaultVersionRepository,
        fileStorage storage.FileStorage,
) VaultService <span class="cov8" title="1">{
        return &amp;vaultService{
                db:               db,
                vaultRepo:        vaultRepo,
                vaultVersionRepo: vaultVersionRepo,
                fileStorage:      fileStorage,
        }
}</span>

// GetVaultMetadata получает метаданные ТЕКУЩЕЙ версии хранилища для пользователя.
func (s *vaultService) GetVaultMetadata(userID int64) (*models.VaultVersion, error) <span class="cov8" title="1">{
        ctx := context.Background()

        _, currentVersion, err := s.vaultRepo.GetVaultWithCurrentVersionByUserID(ctx, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrVaultNotFound) </span><span class="cov8" title="1">{
                        log.Printf("[VaultService] Метаданные (GetVaultWithCurrentVersion) для пользователя %d не найдены", userID)
                        return nil, ErrVaultNotFound
                }</span>
                <span class="cov8" title="1">log.Printf("[VaultService] Ошибка репозитория при получении хранилища с версией для пользователя %d: %v", userID, err)
                return nil, errors.New("внутренняя ошибка сервера при получении метаданных")</span>
        }

        <span class="cov8" title="1">if currentVersion == nil </span><span class="cov8" title="1">{
                // Хранилище есть, но текущей версии нет (например, после неудачного отката)
                log.Printf("[VaultService] У пользователя %d есть хранилище, но нет текущей версии", userID)
                return nil, ErrVaultNotFound // Считаем, что метаданных нет
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultService] Успешно получены метаданные текущей версии (ID: %d)"+
                " для пользователя %d", currentVersion.ID, userID)
        return currentVersion, nil</span>
}

// Добавили contentModifiedAt в параметры.
func (s *vaultService) UploadVault(
        userID int64,
        reader io.Reader,
        size int64,
        contentType string,
        contentModifiedAt time.Time,
) error <span class="cov8" title="1">{
        ctx := context.Background()

        // Загружаем файл и получаем его чек-сумму
        objectKey, checksumClient, err := s.uploadFileToStorage(ctx, userID, reader, size, contentType)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // --- Транзакция БД --- //
        <span class="cov8" title="1">tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultService] Ошибка начала транзакции для пользователя %d: %v", userID, err)
                // TODO: Попытаться удалить загруженный файл из MinIO?
                return errors.New("внутренняя ошибка сервера")
        }</span>
        // Гарантируем откат транзакции в случае паники или ошибки
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback()
                        panic(p)</span> // Передаем панику дальше
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        log.Printf("[VaultService] Ошибка во время транзакции, откат... Error: %v", err)
                        _ = tx.Rollback()
                        // TODO: Попытаться удалить загруженный файл из MinIO?
                }</span> else<span class="cov8" title="1"> {
                        err = tx.Commit()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[VaultService] Ошибка коммита транзакции: %v", err)
                                // TODO: Попытаться удалить загруженный файл из MinIO?
                        }</span>
                }
        }()

        // Получаем текущее хранилище и его ВЕРСИЮ
        <span class="cov8" title="1">vault, currentVersion, err := s.vaultRepo.GetVaultWithCurrentVersionByUserID(ctx, userID) // TODO: Передать tx
        if err != nil &amp;&amp; !errors.Is(err, repository.ErrVaultNotFound) </span><span class="cov0" title="0">{
                // Неожиданная ошибка при поиске
                log.Printf("[VaultService] Ошибка поиска хранилища/версии для пользователя %d: %v", userID, err)
                return errors.New("внутренняя ошибка сервера") // defer откатит транзакцию
        }</span>

        // Сравниваем версии и решаем, нужно ли создавать новую
        <span class="cov8" title="1">shouldCreateNewVersion, err := s.shouldCreateNewVersion(currentVersion, contentModifiedAt, checksumClient)
        if err != nil </span><span class="cov8" title="1">{
                return err // Возвращаем ошибку конфликта, если она возникла
        }</span>

        // Если нужно создать новую версию
        <span class="cov8" title="1">if shouldCreateNewVersion </span><span class="cov8" title="1">{
                err = s.createNewVersion(ctx, vault, userID, objectKey, checksumClient, size, contentModifiedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Ошибки нет (либо была идентичная версия), defer выполнит Commit
        <span class="cov8" title="1">return nil</span>
}

// uploadFileToStorage загружает файл в хранилище и возвращает ключ объекта и чек-сумму.
func (s *vaultService) uploadFileToStorage(
        ctx context.Context,
        userID int64,
        reader io.Reader,
        size int64,
        contentType string,
) (string, string, error) <span class="cov8" title="1">{
        // Используем io.TeeReader, чтобы одновременно считать хеш и передать данные дальше
        hash := sha256.New()
        teeReader := io.TeeReader(reader, hash)

        // Генерируем уникальный ключ объекта для MinIO
        objectKey := fmt.Sprintf("user_%d/vault_%s.kdbx", userID, uuid.New().String())

        // Загружаем файл в MinIO
        err := s.fileStorage.UploadFile(ctx, objectKey, teeReader, size, contentType)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("[VaultService] Ошибка загрузки файла в хранилище для пользователя %d: %v", userID, err)
                return "", "", errors.New("внутренняя ошибка сервера при загрузке файла")
        }</span>

        // Получаем вычисленную чек-сумму клиента
        <span class="cov8" title="1">checksumClient := hex.EncodeToString(hash.Sum(nil))
        log.Printf("[VaultService] Файл для пользователя %d загружен в '%s', SHA256: %s",
                userID, objectKey, checksumClient)

        return objectKey, checksumClient, nil</span>
}

// shouldCreateNewVersion определяет, нужно ли создавать новую версию на основе сравнения с текущей.
func (s *vaultService) shouldCreateNewVersion(
        currentVersion *models.VaultVersion,
        clientTime time.Time,
        checksumClient string,
) (bool, error) <span class="cov8" title="1">{
        // Если текущей версии нет, то создаем новую
        if currentVersion == nil || currentVersion.ContentModifiedAt == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">serverTime := *currentVersion.ContentModifiedAt
        checksumServer := ""
        if currentVersion.Checksum != nil </span><span class="cov8" title="1">{
                checksumServer = *currentVersion.Checksum
        }</span>

        <span class="cov8" title="1">log.Printf("[VaultService] Сравнение версий: Клиент T=%v C=%s | Сервер T=%v C=%s",
                clientTime, checksumClient, serverTime, checksumServer)

        if clientTime.Before(serverTime) </span><span class="cov8" title="1">{
                // Время клиента &lt; времени сервера -&gt; Конфликт
                log.Printf("[VaultService] Отклонено: время клиента (%v) раньше времени сервера (%v). Конфликт.",
                        clientTime, serverTime)
                return false, ErrConflictVersion
        }</span> else<span class="cov8" title="1"> if clientTime.Equal(serverTime) </span><span class="cov8" title="1">{
                // Время совпадает, проверяем чек-суммы
                if checksumClient == checksumServer </span><span class="cov8" title="1">{
                        // Идентичная версия
                        log.Printf("[VaultService] Пропуск: идентичная версия (время и чек-сумма совпадают).")
                        return false, nil
                }</span>
                // Время совпадает, чек-суммы разные -&gt; Конфликт
                <span class="cov8" title="1">log.Printf("[VaultService] Отклонено: время совпадает (%v), но чек-суммы разные. Конфликт.", clientTime)
                return false, ErrConflictVersion</span>
        }

        // Если clientTime.After(serverTime), создаем новую версию
        <span class="cov8" title="1">return true, nil</span>
}

// createNewVersion создает новую версию хранилища или новое хранилище, если оно не существует.
func (s *vaultService) createNewVersion(
        ctx context.Context,
        vault *models.Vault,
        userID int64,
        objectKey string,
        checksumClient string,
        size int64,
        contentModifiedAt time.Time,
) error <span class="cov8" title="1">{
        // Найдем или создадим Vault
        var vaultID int64
        if vault == nil </span><span class="cov8" title="1">{
                // Хранилище не найдено, создаем новое
                log.Printf("[VaultService] Хранилище для пользователя %d не найдено, создаем новое.", userID)
                newVault := &amp;models.Vault{UserID: userID}
                var err error
                vaultID, err = s.vaultRepo.CreateVault(ctx, newVault) // TODO: Передать tx
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Ошибка создания хранилища в транзакции для пользователя %d: %v", userID, err)
                        return errors.New("внутренняя ошибка сервера")
                }</span>
                <span class="cov8" title="1">log.Printf("[VaultService] Новое хранилище создано (ID: %d) для пользователя %d", vaultID, userID)</span>
        } else<span class="cov8" title="1"> {
                vaultID = vault.ID
                log.Printf("[VaultService] Используется существующее хранилище (ID: %d) для пользователя %d", vaultID, userID)
        }</span>

        // Создаем запись о новой версии
        <span class="cov8" title="1">newVersion := &amp;models.VaultVersion{
                VaultID:           vaultID,
                ObjectKey:         objectKey,
                Checksum:          &amp;checksumClient,
                SizeBytes:         &amp;size,
                ContentModifiedAt: &amp;contentModifiedAt,
        }
        versionID, err := s.vaultVersionRepo.CreateVersion(ctx, newVersion) // TODO: Передать tx
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultService] Ошибка создания версии в транзакции для хранилища %d: %v", vaultID, err)
                return errors.New("внутренняя ошибка сервера")
        }</span>
        <span class="cov8" title="1">log.Printf("[VaultService] Новая версия создана (ID: %d) для хранилища %d", versionID, vaultID)

        // Обновляем current_version_id в Vault
        err = s.vaultRepo.UpdateVaultCurrentVersion(ctx, vaultID, versionID) // TODO: Передать tx
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultService] Ошибка обновления current_version_id в транзакции для хранилища %d: %v", vaultID, err)
                return errors.New("внутренняя ошибка сервера")
        }</span>
        <span class="cov8" title="1">log.Printf("[VaultService] current_version_id для хранилища %d обновлен на %d", vaultID, versionID)

        log.Printf("[VaultService] Загрузка и обновление метаданных для пользователя %d завершены успешно", userID)
        return nil</span>
}

// DownloadVault скачивает ТЕКУЩУЮ версию файла хранилища.
func (s *vaultService) DownloadVault(userID int64) (io.ReadCloser, *models.VaultVersion, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Получаем хранилище и текущую версию одним запросом
        _, currentVersion, err := s.vaultRepo.GetVaultWithCurrentVersionByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrVaultNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Запрос на скачивание: хранилище или версия для пользователя %d не найдены", userID)
                        return nil, nil, ErrVaultNotFound
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultService] Ошибка получения хранилища/версии для скачивания (пользователь %d): %v", userID, err)
                return nil, nil, errors.New("внутренняя ошибка сервера при получении метаданных")</span>
        }

        <span class="cov0" title="0">if currentVersion == nil </span><span class="cov0" title="0">{
                log.Printf("[VaultService] Запрос на скачивание: нет текущей активной версии для пользователя %d", userID)
                return nil, nil, ErrVaultNotFound
        }</span>

        // Скачиваем файл из MinIO по ключу текущей версии
        <span class="cov0" title="0">fileReader, err := s.fileStorage.DownloadFile(ctx, currentVersion.ObjectKey)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, storage.ErrObjectNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Файл '%s' не найден в хранилище"+
                                " (пользователь %d, версия %d)", currentVersion.ObjectKey, userID, currentVersion.ID)
                        return nil, nil, ErrVaultNotFound
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultService] Ошибка скачивания файла '%s' из хранилища"+
                        " (пользователь %d, версия %d): %v", currentVersion.ObjectKey, userID, currentVersion.ID, err)
                return nil, nil, errors.New("внутренняя ошибка сервера при скачивании файла")</span>
        }

        <span class="cov0" title="0">log.Printf("[VaultService] Файл '%s' (версия %d) для пользователя %d"+
                " готов к скачиванию", currentVersion.ObjectKey, currentVersion.ID, userID)
        return fileReader, currentVersion, nil</span>
}

// ListVersions возвращает список версий хранилища пользователя.
func (s *vaultService) ListVersions(userID int64, limit, offset int) ([]models.VaultVersion, error) <span class="cov0" title="0">{
        ctx := context.Background()

        // Сначала находим ID хранилища пользователя
        vault, err := s.vaultRepo.GetVaultByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrVaultNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Запрос списка версий: хранилище для пользователя %d не найдено", userID)
                        return []models.VaultVersion{}, nil // Возвращаем пустой слайс, а не ошибку
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultService] Ошибка поиска хранилища для списка версий (пользователь %d): %v", userID, err)
                return nil, errors.New("внутренняя ошибка сервера")</span>
        }

        // Получаем список версий для найденного vaultID
        <span class="cov0" title="0">versions, err := s.vaultVersionRepo.ListVersionsByVaultID(ctx, vault.ID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[VaultService] Ошибка получения списка версий для хранилища %d"+
                        " (пользователь %d): %v", vault.ID, userID, err)
                return nil, errors.New("внутренняя ошибка сервера")
        }</span>

        <span class="cov0" title="0">log.Printf("[VaultService] Возвращено %d версий для пользователя %d", len(versions), userID)
        return versions, nil</span>
}

// RollbackToVersion откатывает хранилище пользователя к указанной версии.
func (s *vaultService) RollbackToVersion(userID int64, versionID int64) error <span class="cov0" title="0">{
        ctx := context.Background()

        // 1. Найти хранилище пользователя
        vault, err := s.vaultRepo.GetVaultByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrVaultNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Попытка отката: хранилище для пользователя %d не найдено", userID)
                        return ErrVaultNotFound
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultService] Ошибка поиска хранилища для отката (пользователь %d): %v", userID, err)
                return errors.New("внутренняя ошибка сервера")</span>
        }

        // 2. Проверить, что указанная версия принадлежит этому хранилищу
        <span class="cov0" title="0">version, err := s.vaultVersionRepo.GetVersionByID(ctx, versionID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrVersionNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Попытка отката: версия %d не найдена (пользователь %d)", versionID, userID)
                        return ErrVersionNotFound // А возвращаем ошибку сервиса
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultService] Ошибка поиска версии %d для отката (пользователь %d): %v", versionID, userID, err)
                return errors.New("внутренняя ошибка сервера")</span>
        }
        <span class="cov0" title="0">if version.VaultID != vault.ID </span><span class="cov0" title="0">{
                log.Printf("[VaultService] Попытка отката: версия %d не принадлежит хранилищу %d"+
                        " (пользователь %d)", versionID, vault.ID, userID)
                return ErrForbidden // Другая ошибка: попытка доступа к чужой версии
        }</span>

        // 3. Обновить current_version_id в хранилище
        <span class="cov0" title="0">err = s.vaultRepo.UpdateVaultCurrentVersion(ctx, vault.ID, versionID)
        if err != nil </span><span class="cov0" title="0">{
                // Обрабатываем случай, если хранилище вдруг не нашлось (хотя мы его только что нашли)
                if errors.Is(err, repository.ErrVaultNotFound) </span><span class="cov0" title="0">{
                        log.Printf("[VaultService] Ошибка отката: хранилище %d исчезло во время обновления?"+
                                " (пользователь %d)", vault.ID, userID)
                        return ErrVaultNotFound
                }</span>
                <span class="cov0" title="0">log.Printf("[VaultService] Ошибка обновления current_version_id при откате"+
                        " для хранилища %d (пользователь %d): %v", vault.ID, userID, err)
                return errors.New("внутренняя ошибка сервера при откате")</span>
        }

        <span class="cov0" title="0">log.Printf("[VaultService] Пользователь %d успешно откатил хранилище %d к версии %d", userID, vault.ID, versionID)
        return nil</span>
}

// Кастомные ошибки сервиса.
var (
        ErrVaultNotFound   = errors.New("хранилище или его версия не найдены")
        ErrVersionNotFound = errors.New("указанная версия хранилища не найдена")
        ErrForbidden       = errors.New("доступ запрещен") // Общая ошибка доступа
        ErrConflictVersion = errors.New("конфликт версий")
)
</pre>
		
		<pre class="file" id="file11" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
)

// FileStorage определяет интерфейс для взаимодействия с объектным хранилищем.
type FileStorage interface {
        UploadFile(ctx context.Context, objectKey string, reader io.Reader, size int64, contentType string) error
        DownloadFile(ctx context.Context, objectKey string) (io.ReadCloser, error)
        // TODO: Добавить другие методы, если понадобятся (например, DeleteFile, GetFileInfo)
}

// MinioClient реализует FileStorage для MinIO.
type MinioClient struct {
        client     *minio.Client
        bucketName string
}

// MinioConfig содержит параметры для подключения к MinIO.
type MinioConfig struct {
        Endpoint        string // Адрес MinIO (например, "localhost:9000")
        AccessKeyID     string // Логин
        SecretAccessKey string // Пароль
        UseSSL          bool   // Использовать SSL (обычно false для локальной разработки)
        BucketName      string // Имя бакета для хранения файлов
        Region          string // Регион (не обязательно для MinIO, но может требоваться)
}

// NewMinioClient создает новый клиент MinIO.
func NewMinioClient(cfg MinioConfig) (*MinioClient, error) <span class="cov0" title="0">{
        log.Printf("Инициализация клиента MinIO для эндпоинта %s...", cfg.Endpoint)

        // Инициализация клиента MinIO
        minioClient, err := minio.New(cfg.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(cfg.AccessKeyID, cfg.SecretAccessKey, ""),
                Secure: cfg.UseSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка инициализации клиента MinIO: %w", err)
        }</span>

        // Проверка доступности MinIO
        // Необязательно, но полезно для раннего обнаружения проблем
        <span class="cov0" title="0">_, err = minioClient.ListBuckets(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Предупреждение: не удалось проверить соединение с MinIO: %v. Проверьте доступность и креды.", err)
                // Не возвращаем ошибку, чтобы сервер мог запуститься, даже если MinIO временно недоступен
        }</span>

        // Проверка существования бакета и создание при необходимости
        <span class="cov0" title="0">ctx := context.Background()
        exists, err := minioClient.BucketExists(ctx, cfg.BucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка проверки существования бакета '%s': %w", cfg.BucketName, err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                log.Printf("Бакет '%s' не найден, попытка создания...", cfg.BucketName)
                err = minioClient.MakeBucket(ctx, cfg.BucketName, minio.MakeBucketOptions{Region: cfg.Region})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка создания бакета '%s': %w", cfg.BucketName, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Бакет '%s' успешно создан.", cfg.BucketName)</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Бакет '%s' уже существует.", cfg.BucketName)
        }</span>

        <span class="cov0" title="0">log.Printf("Клиент MinIO успешно инициализирован для бакета '%s'.", cfg.BucketName)
        return &amp;MinioClient{
                client:     minioClient,
                bucketName: cfg.BucketName,
        }, nil</span>
}

// UploadFile загружает файл в MinIO.
func (c *MinioClient) UploadFile(
        ctx context.Context,
        objectKey string,
        reader io.Reader,
        size int64,
        contentType string,
) error <span class="cov0" title="0">{
        log.Printf("[Minio] Загрузка файла '%s' в бакет '%s'...", objectKey, c.bucketName)

        // Опции загрузки
        opts := minio.PutObjectOptions{
                ContentType: contentType,
                // Можно добавить другие метаданные при необходимости
                // UserMetadata: map[string]string{"x-amz-meta-my-key": "your-value"},
        }

        // Загружаем объект
        uploadInfo, err := c.client.PutObject(ctx, c.bucketName, objectKey, reader, size, opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[Minio] Ошибка загрузки файла '%s': %v", objectKey, err)
                return fmt.Errorf("ошибка загрузки файла в MinIO: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[Minio] Файл '%s' успешно загружен, размер: %d, ETag: %s", objectKey, uploadInfo.Size, uploadInfo.ETag)
        return nil</span>
}

// DownloadFile скачивает файл из MinIO.
// Возвращает io.ReadCloser, который нужно закрыть после использования.
func (c *MinioClient) DownloadFile(ctx context.Context, objectKey string) (io.ReadCloser, error) <span class="cov0" title="0">{
        log.Printf("[Minio] Скачивание файла '%s' из бакета '%s'...", objectKey, c.bucketName)

        // Получаем объект
        object, err := c.client.GetObject(ctx, c.bucketName, objectKey, minio.GetObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // Проверяем, является ли ошибка "NoSuchKey"
                var minioErr minio.ErrorResponse
                if errors.As(err, &amp;minioErr) &amp;&amp; minioErr.Code == "NoSuchKey" </span><span class="cov0" title="0">{
                        log.Printf("[Minio] Файл '%s' не найден в бакете '%s'", objectKey, c.bucketName)
                        return nil, ErrObjectNotFound // Возвращаем кастомную ошибку
                }</span>
                <span class="cov0" title="0">log.Printf("[Minio] Ошибка получения файла '%s': %v", objectKey, err)
                return nil, fmt.Errorf("ошибка получения файла из MinIO: %w", err)</span>
        }

        // Проверяем метаданные объекта (необязательно, но может быть полезно)
        /*
                stat, err := object.Stat()
                if err != nil {
                        // Важно закрыть тело объекта, даже если Stat() вернул ошибку
                        _ = object.Close()
                        log.Printf("[Minio] Ошибка получения метаданных для файла '%s': %v", objectKey, err)
                        return nil, fmt.Errorf("ошибка получения метаданных из MinIO: %w", err)
                }
                log.Printf("[Minio] Файл '%s' найден, размер: %d, ContentType: %s", objectKey, stat.Size, stat.ContentType)
        */

        <span class="cov0" title="0">log.Printf("[Minio] Файл '%s' успешно получен для скачивания", objectKey)
        return object, nil</span> // Возвращаем тело объекта (io.ReadCloser)
}

// Кастомная ошибка хранилища.
var (
        ErrObjectNotFound = errors.New("объект не найден в хранилище")
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
